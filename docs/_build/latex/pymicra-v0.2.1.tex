% Generated by Sphinx.
\def\sphinxdocclass{report}
\newif\ifsphinxKeepOldNames \sphinxKeepOldNamestrue
\documentclass[a4paper,10pt,oneside]{sphinxmanual}
\usepackage{iftex}

\ifPDFTeX
  \usepackage[utf8]{inputenc}
\fi
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage[english]{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}


\title{Pymicra Documentation}
\date{2016-08-06}
\release{0.2.1}
\author{Tomás Chor}
\newcommand{\sphinxlogo}{\sphinxincludegraphics{starry2.jpg}\par}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Pymicra is a Python package designed to make it easier to work with
micrometeorological datasets. It is aimed at improving the productivity and
allowing us to focus on the micrometeorological issues, rather than programming
ones.

Please check out the \href{https://github.com/tomchor/pymicra}{Github page} and the \href{https://tomchor.github.io/pymicra}{documentation}.

Here's a quick (incomplete!) list of what Pymicra does:
\begin{itemize}
\item {} 
Reading, separating and understanding micrometeorological data in
virtually any column-separated ASCII format (thanks to pandas).

\item {} 
Quality control methods (max and min values check, spikes,
reverse-arrangement test and etc..

\item {} 
Rotation of coordinates (2D).

\item {} 
Detrending of data in the most common ways (block averages, moving
averages and polynomial detrending).

\item {} 
Correction of sensor drift.

\item {} 
Automatic calculation of most auxiliary variables based on
measurements (air density, dry air density, etc.).

\item {} 
Calculation of spectra and cross-spectra.

\item {} 
Calculation fluxes and characteristic scales with or without WPL correction.

\item {} 
Provide common constants generally used in atmospheric sciences.

\item {} 
Plus all native features of Pandas (interpolation, resampling,
grouping, statistical tests, slicing, handling of missing data and
etc.).

\end{itemize}

The package is extensively (almost entirely) based on Pandas, mostly the
\sphinxcode{pandas.DataFrame} class. We use Pint for units control and (generally) Numpy
or Scipy for some numerical functions not contained in Pandas.


\chapter{Introduction}
\label{intro:introduction}\label{intro:pymicra-a-python-tool-for-micrometeorological-analyses}\label{intro::doc}\label{intro:id2}
Pymicra is a Python package that was created to condense many of the knowledge
of the micrometeorological community in one single fast-to-implement software
that is freely available to anyone. Because of that, I made an effort to
include a detailed docstring along with every function and class. By doing that
I hope to have made every function, class etc. pretty self-explanatory, both
within the auto-generated docs (thanks to Sphinx) and by importing the package
and running \sphinxcode{help(pymicra.timeSeries)}, for example.

Since Pymicra is meant to be a community package, improvements, suggestions of
improvement, and any kind of feedback are highly appreciated. The code is
available at its \href{https://github.com/tomchor/pymicra}{Github page} and any contact can be made through there
(possibly creating an \href{https://github.com/tomchor/pymicra/issues}{Github issue}) or via email (tomaschor {[}at{]} gmail.com).


\section{Quick notes}
\label{intro:quick-notes}
In order for the user to program fast and effectively (and to reduce the time it
takes me to write its code), Pymicra was written on top of the
\href{http://pandas.pydata.org/}{Pandas package}, so that it is faster to run
the same code using Pymicra than it is running pure Python. As a consequence,
Pymicra makes extensive use of Pandas' DataFrame class, which is a very useful
2-D data structure optimized for performance and for timestamp-indexed data.

It is possible to use Pymicra without having to be familiar with Pandas, but
because Pymicra depends on Pandas, I suggest at the very least that the user
take a quick look at a Pandas tutorial
\href{http://pandas.pydata.org/pandas-docs/stable/10min.html}{this one for example}
so that one can be familiarized with the many functionalities that
Pandas offers in order to take full advantage of Pymicra.


\section{Contributing}
\label{intro:contributing}
Currently, this project has only one part-time developer. This makes it hard to
feed Pymicra with up-to-date information/routines as the state-of-the-art
micrometeorology evolves quickly. The ideal scenario is one where
micrometeorologists in the community not only use Pymicra, but also contribute
to it, whether it's by adding to the code, finding bugs, investing ideas and
etc. Thus, I have made an effort to not only document the routines/functions in
the docstring, but also detail them with comments throughout the code. This was
done specially to make it easier for other people to contribute.

If you want to contribute with code you can either create a Github account and
contact me via the \href{https://github.com/tomchor/pymicra}{Github page} by creating an issue/pull request, or you can
contact me directly by email (tomaschor {[}at{]} gmail.com). Furthermore, if you have some useful routines
laying around (or even some routines with a procedure you recently created and
published) but aren't sure how to make them Pymicra-compatible, let me know by
email and we'll work together to adapt it.

Cheers

Tomás Chor.


\chapter{Installation}
\label{install:installation}\label{install::doc}
\begin{notice}{warning}{Warning:}
The commands written here assume you are running a Ubuntu-based distribution of
Linux. Although the basic steps should be similar for all Linux distributions, you
should adapt the specific commands to your system in case you are using any other OS.
\end{notice}

Most of the required packages already come with python, such as \sphinxcode{datetime} or
\sphinxcode{os}. The packages that may not come as default are:
\begin{itemize}
\item {} 
\href{http://pandas.pydata.org/}{Pandas} (recommended 0.17.1)

\item {} 
\href{https://pint.readthedocs.io/en/0.7.2/}{Pint} (0.7.2)

\item {} 
\href{http://www.numpy.org/}{Numpy}

\item {} 
\href{https://www.scipy.org/}{Scipy}

\item {} 
setuptools (for installation only)

\end{itemize}

\begin{notice}{note}{Note:}
Version 0.17.1 of Pandas is suggested, but it should work fine with any
distribution from 0.13 up to 0.17.1. However, version 0.18 upwards is not
currently supported because of a change in the rolling functions API.
\end{notice}

In order to install Pymicra the \sphinxcode{setuptools} Python package should be
installed beforehand. If you don't have it installed already you can install it
with \sphinxcode{sudo apt install python-setuptools} or \sphinxcode{sudo pip install setuptools}.

Once \sphinxcode{setuptools} is installed, download the package from the \href{https://github.com/tomchor/pymicra}{Github page},
unpack it somewhere, then run \sphinxcode{setup.py} on a terminal with the \sphinxcode{install}
directive. Assuming the file is downloaded into the Downloads directory:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd} \PYGZti{}/Downloads
unzip pymicra\PYGZhy{}master.zip
cp pymicra\PYGZhy{}master
sudo python setup.py install
\end{Verbatim}

This should successfully install Pymicra. Note that the \sphinxcode{pymicra-master} may
be different depending on whether you download directly from the master branch,
the dev branch or a specific release on Github.

Although fairly general, I have tested the setup program on a limited number of
computers so far, so it is possible that an error occurs depending on the
version of some auxiliary packages you have installed. If that happens, please
contact me through email or creating a \href{https://github.com/tomchor/pymicra/issues}{Github issue} detailing your problem and I
will try to improve the setup file accordingly. Alternatively, you may also try
to manually install versions 1.11.0 of \href{http://www.numpy.org/}{Numpy} and 0.17.0 of \href{https://www.scipy.org/}{Scipy} and then
running \sphinxcode{sudo python setup.py install} again.

To remove Pymicra, the easiest way is to use pip (\sphinxcode{sudo apt install
python-pip}) with the command \sphinxcode{sudo pip uninstall pymicra}.


\chapter{Getting started}
\label{basics:getting-started}\label{basics::doc}
This ``Getting started'' tutorial is a brief introduction to Pymicra. This is in
no way supposed to be a complete representation of everything that can be done
with Pymicra.

In this tutorial we use some example data and refer to some example python
scripts that can be downloaded \href{https://github.com/tomchor/pymicra/tree/master/examples}{here}. These data and
scripts are from a measurement campaign in a very small island (about 20 meters
across) in a large artificial lake. At the time of these measurements the
island was almost completely immersed into about 5 cm of water. Please feel
free to explore both the example data and the example programs, as well as
modify the programs for your own learning process!


\section{Notation}
\label{basics:notation}
Pymicra uses a specific notation to name each one of its columns. This notation
is extremely important, because it is by these labels that Pymicra knows which
variable is in each column. You can check the default notation with

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [1]: }\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{capture}
\PYG{g+gp}{   ...: }\PYG{k+kn}{import} \PYG{n+nn}{pymicra} \PYG{k+kn}{as} \PYG{n+nn}{pm}
\PYG{g+gp}{   ...: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{pm}\PYG{o}{.}\PYG{n}{notation}\PYG{p}{)}
\PYG{g+gp}{   ...: }
\end{Verbatim}

The output is too long to be reproduced here, but on the left you'll see the
full name of the variables (which corresponds to a notation
namespace/attribute) and on the right you'll see the default notation for that
variable.

We recommend to use the default notation for the sake of simplicity, however,
you can change Pymicra's notation at any time by altering the attributes of
\sphinxcode{pm.notation}. For example, by default the notation for the mean is
\sphinxcode{'\%s\_mean'}, and every variable follows this base notation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [2]: }\PYG{n}{pm}\PYG{o}{.}\PYG{n}{notation}\PYG{o}{.}\PYG{n}{mean}
\PYG{g+gh}{Out[2]: }\PYG{g+go}{\PYGZsq{}\PYGZpc{}s\PYGZus{}mean\PYGZsq{}}

\PYG{g+gp}{In [3]: }\PYG{n}{pm}\PYG{o}{.}\PYG{n}{notation}\PYG{o}{.}\PYG{n}{mean\PYGZus{}u}
\PYG{g+gh}{Out[3]: }\PYG{g+go}{\PYGZsq{}u\PYGZus{}mean\PYGZsq{}}

\PYG{g+gp}{In [4]: }\PYG{n}{pm}\PYG{o}{.}\PYG{n}{notation}\PYG{o}{.}\PYG{n}{mean\PYGZus{}h2o\PYGZus{}mass\PYGZus{}concentration}
\PYG{g+gh}{Out[4]: }\PYG{g+go}{\PYGZsq{}conc\PYGZus{}h2o\PYGZus{}mean\PYGZsq{}}
\end{Verbatim}

To change this, you have to change the \sphinxcode{mean} notation and then re-build the
whole notation with the \sphinxcode{build} method:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [5]: }\PYG{n}{pm}\PYG{o}{.}\PYG{n}{notation}\PYG{o}{.}\PYG{n}{mean} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{m\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{g+gp}{In [6]: }\PYG{n}{pm}\PYG{o}{.}\PYG{n}{notation}\PYG{o}{.}\PYG{n}{build}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{In [7]: }\PYG{n}{pm}\PYG{o}{.}\PYG{n}{notation}\PYG{o}{.}\PYG{n}{mean\PYGZus{}u}
\PYG{g+gh}{Out[7]: }\PYG{g+go}{\PYGZsq{}m\PYGZus{}u\PYGZsq{}}

\PYG{g+gp}{In [8]: }\PYG{n}{pm}\PYG{o}{.}\PYG{n}{notation}\PYG{o}{.}\PYG{n}{mean\PYGZus{}h2o\PYGZus{}mass\PYGZus{}concentration}
\PYG{g+gh}{Out[8]: }\PYG{g+go}{\PYGZsq{}m\PYGZus{}conc\PYGZus{}h2o\PYGZsq{}}

\PYG{g+gp}{In [9]: }\PYG{n}{pm}\PYG{o}{.}\PYG{n}{notation}\PYG{o}{.}\PYG{n}{h2o}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{g+gp}{In [10]: }\PYG{n}{pm}\PYG{o}{.}\PYG{n}{notation}\PYG{o}{.}\PYG{n}{build}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{In [11]: }\PYG{n}{pm}\PYG{o}{.}\PYG{n}{notation}\PYG{o}{.}\PYG{n}{mean\PYGZus{}h2o\PYGZus{}mass\PYGZus{}concentration}
\PYG{g+gh}{Out[11]: }\PYG{g+go}{\PYGZsq{}m\PYGZus{}conc\PYGZus{}v\PYGZsq{}}
\end{Verbatim}

If you just want to change the notation of one variable, but not the full
notation, just don't re-build. For example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [12]: }\PYG{n}{pm}\PYG{o}{.}\PYG{n}{notation}\PYG{o}{.}\PYG{n}{mean\PYGZus{}co2\PYGZus{}mass\PYGZus{}concentration} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c\PYGZus{}m}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{g+gp}{In [13]: }\PYG{n}{pm}\PYG{o}{.}\PYG{n}{notation}\PYG{o}{.}\PYG{n}{mean\PYGZus{}co2\PYGZus{}mass\PYGZus{}concentration}
\PYG{g+gh}{Out[13]: }\PYG{g+go}{\PYGZsq{}c\PYGZus{}m\PYGZsq{}}

\PYG{g+gp}{In [14]: }\PYG{n}{pm}\PYG{o}{.}\PYG{n}{notation}\PYG{o}{.}\PYG{n}{mean\PYGZus{}h2o\PYGZus{}mass\PYGZus{}concentration}
\PYG{g+gh}{Out[14]: }\PYG{g+go}{\PYGZsq{}m\PYGZus{}conc\PYGZus{}v\PYGZsq{}}
\end{Verbatim}

It is important to note that this changes the notation used throughout every
Pymicra function.  If, however, you want to use a different notation in a
specific part of the program (in one specific function for example) you can
create a Notation object and pass it to the function, such as

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [15]: }\PYG{n}{mynotation} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{Notation}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{In [16]: }\PYG{n}{mynotation}\PYG{o}{.}\PYG{n}{co2}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{g+gp}{In [17]: }\PYG{n}{mynotation}\PYG{o}{.}\PYG{n}{build}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{In [18]: }\PYG{n}{fluxes} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{eddyCovariance}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{units}\PYG{p}{,} \PYG{n}{notation}\PYG{o}{=}\PYG{n}{mynotation}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} For example}
\end{Verbatim}

In the example above the default Pymicra notation is left untouched, and a
separate notation is defined which is then used in a Pymicra function
separately.


\section{Creating file configurations file}
\label{basics:creating-file-configurations-file}
The easiest way to read data files is using a \sphinxcode{fileConfig} object. This object holds
the configuration of the data files so you can just call this object when reading these files.
To make it easier, Pymicra prefers to read this configurations from a file. That way
you can write the configurations for some data files once, store it into a configuration file
and then use it from then on every time you want to read those data files. That is what
Pymicra calls a ``file configuration file'', or ``config file'' for short. From that
file, Pymicra can create a \sphinxcode{pymicra.fileConfig} object. Consider, for example, the config
file below

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{description}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{datalogger configuration file for a lake. Located at examples/lake.config}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n}{variables}\PYG{o}{=}\PYG{p}{\PYGZob{}}
\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{Y\PYGZhy{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{m\PYGZhy{}}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{H:}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{M:}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{S.}\PYG{l+s+si}{\PYGZpc{}f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+m+mi}{4}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+m+mi}{5}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{theta\PYGZus{}v}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+m+mi}{6}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mrho\PYGZus{}h2o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+m+mi}{7}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mrho\PYGZus{}co2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+m+mi}{8}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{p}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+m+mi}{9}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{theta}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}

\PYG{n}{units}\PYG{o}{=}\PYG{p}{\PYGZob{}}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{m/s}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{m/s}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{m/s}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{theta\PYGZus{}v}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{celsius}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mrho\PYGZus{}co2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mmol/m**3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mrho\PYGZus{}h2o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mmol/m**3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{p}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{kPa}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{theta}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{celsius}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{p}{\PYGZcb{}}

\PYG{n}{columns\PYGZus{}separator}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{frequency}\PYG{o}{=}\PYG{l+m+mi}{20}
\PYG{n}{header\PYGZus{}lines}\PYG{o}{=}\PYG{k+kc}{None}

\PYG{n}{filename\PYGZus{}format}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{m}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{M.csv}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{date\PYGZus{}cols} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
\end{Verbatim}

First of all, note that the \sphinxcode{.config} file is written in Python syntax, so it
has to be able to actually be run on python. This has to be true for all
\sphinxcode{.config} files.

Furthermore, the extension of the file does not matter. We adopt the
\sphinxcode{.config} extension for clarity, but it could be anything else.

The previous config file describes the data files in the directory
\sphinxcode{../examples/ex\_data/}. Here's an example of one such file for comparison:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mf}{00.000000}\PYG{p}{,}\PYG{l+m+mf}{2.375}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.206}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.103}\PYG{p}{,}\PYG{l+m+mf}{27.06}\PYG{p}{,}\PYG{l+m+mf}{1238.0}\PYG{p}{,}\PYG{l+m+mf}{14.675}\PYG{p}{,}\PYG{l+m+mf}{99.19}\PYG{p}{,}\PYG{l+m+mf}{30.43}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.303}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.274}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.269}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.261}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mf}{00.050000}\PYG{p}{,}\PYG{l+m+mf}{2.4930000000000003}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.098}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.018000000000000002}\PYG{p}{,}\PYG{l+m+mf}{27.12}\PYG{p}{,}\PYG{l+m+mf}{1196.0}\PYG{p}{,}\PYG{l+m+mf}{14.409}\PYG{p}{,}\PYG{l+m+mf}{99.199}\PYG{p}{,}\PYG{l+m+mf}{30.43}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.308}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.275}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.271}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.263}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mf}{00.100000}\PYG{p}{,}\PYG{l+m+mf}{2.263}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.114}\PYG{p}{,}\PYG{l+m+mf}{0.014}\PYG{p}{,}\PYG{l+m+mf}{27.11}\PYG{p}{,}\PYG{l+m+mf}{1220.0}\PYG{p}{,}\PYG{l+m+mf}{14.636}\PYG{p}{,}\PYG{l+m+mf}{99.102}\PYG{p}{,}\PYG{l+m+mf}{30.43}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.306}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.277}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.273}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.263}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mf}{00.150000}\PYG{p}{,}\PYG{l+m+mf}{2.21}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.235}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.012}\PYG{p}{,}\PYG{l+m+mf}{27.11}\PYG{p}{,}\PYG{l+m+mf}{1238.0}\PYG{p}{,}\PYG{l+m+mf}{14.688}\PYG{p}{,}\PYG{l+m+mf}{99.154}\PYG{p}{,}\PYG{l+m+mf}{30.43}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.308}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.277}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.273}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.264}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mf}{00.200000}\PYG{p}{,}\PYG{l+m+mf}{2.158}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.174}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.112}\PYG{p}{,}\PYG{l+m+mf}{27.12}\PYG{p}{,}\PYG{l+m+mf}{1174.0}\PYG{p}{,}\PYG{l+m+mf}{14.476}\PYG{p}{,}\PYG{l+m+mf}{99.154}\PYG{p}{,}\PYG{l+m+mf}{30.44}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.31}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.277}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.273}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.264}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mf}{00.250000}\PYG{p}{,}\PYG{l+m+mf}{2.334}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.279}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.092}\PYG{p}{,}\PYG{l+m+mf}{27.1}\PYG{p}{,}\PYG{l+m+mf}{1195.0}\PYG{p}{,}\PYG{l+m+mf}{14.671}\PYG{p}{,}\PYG{l+m+mf}{99.154}\PYG{p}{,}\PYG{l+m+mf}{30.43}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.308}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.278}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.273}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.265}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mf}{00.300000}\PYG{p}{,}\PYG{l+m+mf}{2.396}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.2970000000000015}\PYG{p}{,}\PYG{l+m+mf}{0.005}\PYG{p}{,}\PYG{l+m+mf}{27.15}\PYG{p}{,}\PYG{l+m+mf}{1198.0}\PYG{p}{,}\PYG{l+m+mf}{14.669}\PYG{p}{,}\PYG{l+m+mf}{99.154}\PYG{p}{,}\PYG{l+m+mf}{30.43}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.309}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.279}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.272}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.264}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mf}{00.350000}\PYG{p}{,}\PYG{l+m+mf}{2.494}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.246}\PYG{p}{,}\PYG{l+m+mf}{0.039}\PYG{p}{,}\PYG{l+m+mf}{27.13}\PYG{p}{,}\PYG{l+m+mf}{1197.0}\PYG{p}{,}\PYG{l+m+mf}{14.722}\PYG{p}{,}\PYG{l+m+mf}{99.154}\PYG{p}{,}\PYG{l+m+mf}{30.44}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.311}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.279}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.273}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.264}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mf}{00.400000}\PYG{p}{,}\PYG{l+m+mf}{2.263}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.317}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.079}\PYG{p}{,}\PYG{l+m+mf}{27.12}\PYG{p}{,}\PYG{l+m+mf}{1202.0}\PYG{p}{,}\PYG{l+m+mf}{14.709}\PYG{p}{,}\PYG{l+m+mf}{99.154}\PYG{p}{,}\PYG{l+m+mf}{30.43}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.311}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.279}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.275}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.265}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mf}{00.450000}\PYG{p}{,}\PYG{l+m+mf}{2.135}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.176}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.036000000000000004}\PYG{p}{,}\PYG{l+m+mf}{27.08}\PYG{p}{,}\PYG{l+m+mf}{1202.0}\PYG{p}{,}\PYG{l+m+mf}{14.731}\PYG{p}{,}\PYG{l+m+mf}{99.154}\PYG{p}{,}\PYG{l+m+mf}{30.44}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.314}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.279}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.275}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.267}
\end{Verbatim}

Note that not all columns of this file are described. Columns that are not
described are also read but are discarded by default. You can change that using
\sphinxcode{only\_named\_columns=False} in the \sphinxcode{timeSeries} function.

We obtain the config object with

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [19]: }\PYG{n}{fconfig} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{fileConfig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../examples/lake.config}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{g+gp}{In [20]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{fconfig}\PYG{p}{)}
\PYG{g+go}{\PYGZlt{}pymicra.fileConfig\PYGZgt{}}
\PYG{g+go}{datalogger configuration file for a lake. Located at examples/lake.config}
\end{Verbatim}

Each variable defined in this file works as a keyword, since it can also be
input manually when calling \sphinxcode{pymicra.fileConfig()}. Thus, for more
information, you can also use \sphinxcode{help(pymicra.fileConfig)}. Now we explain the
keywords one by one. In the next section we will explain how to use this object
for reading a data file.


\subsection{description}
\label{basics:description}
The description is optional. It's a string that serves only to better identify
the config file you're dealing with. It might useful for storage purposes and useful
when printing the config object.


\subsection{variables}
\label{basics:variables}
The most important keyword is \sphinxcode{variables}. This is a python dictionary where
each key is a column and its corresponding value is the variable in that
column. Note that we are using here the default notation to indicate which
variable is in which column. If a different notation is to be used here, then
you will have to define a new notation in your program (refer back to
{\hyperref[basics:notation]{\sphinxcrossref{Notation}}} for that).

\begin{notice}{note}{Note:}
From this point on, for simplicity,  we will assume that the default notation is used.
\end{notice}

It is imperative that the columns be named accordingly. For example, measuring
H$_{\text{2}}$O contents in mmol/m\textasciicircum{}3 is different from measuring it in g/m\textasciicircum{}3 or mg/g. The
first is a molar density (moles per volume), the second is a mass density (mass
per volume) and the third is a mass concentration (mass per mass). In the
default notation these are indicated by the names \sphinxcode{'mrho\_h2o'}, \sphinxcode{'rho\_h2o'}
and \sphinxcode{'conc\_h2o'}, respectively, and Pymicra needs to know which one is which.

Columns that contain parts of the timestamp have to have their name matching
Python's \href{https://docs.python.org/2/library/datetime.html\#strftime-and-strptime-behavior}{date format string directive},
which themselves are the 1989 version default C standard format dates, which is
common in many platforms.

This is useful only in case you want to index your data by timestamp, which is
a huge advantage in some cases (check out what \href{http://pandas.pydata.org/}{Pandas} can do with
\href{http://pandas.pydata.org/pandas-docs/stable/timeseries.html}{timestamp-indexed data}) but Pymicra
can also work well without this. If you don't wish to work with timestamps and
want to work only by line number in each file, you can ignore these columns and
indicate that you don't want to parse dates. In fact, parsing of dates makes
Pymicra a lot slower. Reading a file parsing its dates is about 5.5 times
slower than reading the same file without parsing any dates!


\subsection{units}
\label{basics:units}
The \sphinxcode{units} keyword is also very important. It tells Pymicra in which units
each variable is being measured. Units are handled by \href{https://pint.readthedocs.io/en/0.7.2/}{Pint}, so for more
details on how to define the units please refer to their documentation. Suffices
to say here that the format of the units are pretty intuitive. Some quick remarks
are
\begin{itemize}
\item {} 
prefer to define units unambiguously (\sphinxcode{'g/(m*(s**2))'} is generally preferred to \sphinxcode{'g/m/s**2'}, although both will work).

\item {} 
to define that a unit is dimensionless, \sphinxcode{'1'} will not work. Define it as \sphinxcode{'dimensionless'} or \sphinxcode{'g/g'} and so on.

\item {} 
if one variable does not have a unit (such as a sensor flag), you don't have to include that variable.

\item {} 
the keys of \sphinxcode{units} \textbf{should exactly match} the values of \sphinxcode{variables}.

\end{itemize}


\subsection{columns\_separator}
\label{basics:columns-separator}
The \sphinxcode{columns\_separator} keyword is what it sounds: what separates one column
from the other.  Generally it is one character, such as a comma. A special case
happens is if the columns are separated by whitespaces of varying length, or
tabs. In that case it should be \sphinxcode{"whitespace"}.


\subsection{frequency}
\label{basics:frequency}
The \sphinxcode{frequency} keyword is the frequency of the data collection in Hertz.


\subsection{header\_lines}
\label{basics:header-lines}
The keyword \sphinxcode{header\_lines} tells us which of the first lines are part of
the file header.  If there is no header then is should be \sphinxcode{None}. If there
are header lines than it should be a list or int. For example, if the first two
lines of the file are part of a header, it should be \sphinxcode{{[}0, 1{]}}. If it were the
4 first lines, \sphinxcode{{[}0, 1, 2, 3{]}} (\sphinxcode{range(4)} would also be acceptable).

Header lines are not used by Pymicra and are therefore skipped.


\subsection{filename\_format}
\label{basics:filename-format}
The \sphinxcode{filename\_format} keyword tells Pymicra how the data files are named.


\subsection{date\_cols}
\label{basics:date-cols}
The \sphinxcode{date\_cols} keyword is optional. It is a list of integers that indicates
which of the columns are a part of the timestamp. If it's not provided, then
Pymicra will assume that columns whose names have the character ``\%'' in them are
part of the date and will try to parse them. If the default notation is used,
this should always be true.


\section{Reading data}
\label{basics:reading-data}
To read a data file or a list of data files we use the function \sphinxcode{timeSeries} along with
a config file. Let us use the config file defined in the previous subsection with one of the data
file it describes:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [21]: }\PYG{n}{fname} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../examples/ex\PYGZus{}data/20131108\PYGZhy{}1000.csv}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{g+gp}{In [22]: }\PYG{n}{fconfig} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{fileConfig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../examples/lake.config}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{g+gp}{In [23]: }\PYG{n}{data}\PYG{p}{,} \PYG{n}{units} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{timeSeries}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{,} \PYG{n}{fconfig}\PYG{p}{,} \PYG{n}{parse\PYGZus{}dates}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{g+gp}{In [24]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\PYG{g+go}{                             u      v      w  theta\PYGZus{}v  mrho\PYGZus{}h2o  mrho\PYGZus{}co2       p  theta}
\PYG{g+go}{Timestamp                                                                               }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.000  2.375 \PYGZhy{}5.206 \PYGZhy{}0.103    27.06      1238    14.675  99.190  30.43}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.050  2.493 \PYGZhy{}5.098 \PYGZhy{}0.018    27.12      1196    14.409  99.199  30.43}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.100  2.263 \PYGZhy{}5.114  0.014    27.11      1220    14.636  99.102  30.43}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.150  2.210 \PYGZhy{}5.235 \PYGZhy{}0.012    27.11      1238    14.688  99.154  30.43}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.200  2.158 \PYGZhy{}5.174 \PYGZhy{}0.112    27.12      1174    14.476  99.154  30.44}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.250  2.334 \PYGZhy{}5.279 \PYGZhy{}0.092    27.10      1195    14.671  99.154  30.43}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.300  2.396 \PYGZhy{}5.297  0.005    27.15      1198    14.669  99.154  30.43}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.350  2.494 \PYGZhy{}5.246  0.039    27.13      1197    14.722  99.154  30.44}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.400  2.263 \PYGZhy{}5.317 \PYGZhy{}0.079    27.12      1202    14.709  99.154  30.43}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.450  2.135 \PYGZhy{}5.176 \PYGZhy{}0.036    27.08      1202    14.731  99.154  30.44}
\PYG{g+go}{...                        ...    ...    ...      ...       ...       ...     ...    ...}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.500  4.951 \PYGZhy{}4.584  0.420    28.03      1261    14.772  99.102  32.08}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.550  5.057 \PYGZhy{}4.436  0.492    28.00      1181    14.718  99.138  32.07}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.600  5.145 \PYGZhy{}4.424  0.409    28.10      1216    14.889  99.112  32.08}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.650  5.282 \PYGZhy{}4.038  0.448    28.03      1198    14.485  99.112  32.06}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.700  5.065 \PYGZhy{}4.453  0.424    28.11      1184    14.578  99.138  32.07}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.750  5.262 \PYGZhy{}4.703  0.126    27.98      1264    14.929  99.138  32.08}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.800  5.323 \PYGZhy{}4.882  0.242    27.95      1229    14.258  99.138  32.07}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.850  5.344 \PYGZhy{}5.119  0.457    27.96      1198    14.962  99.102  32.07}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.900  5.281 \PYGZhy{}5.261  0.599    28.09      1231    14.615  99.112  32.07}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.950  5.235 \PYGZhy{}4.801  0.362    28.02      1211    14.682  99.164  32.08}

\PYG{g+go}{[72000 rows x 8 columns]}
\end{Verbatim}

Note that \sphinxcode{data} is a \sphinxcode{pandas.DataFrame} object which contains the whole
data available in the datafile with each column being a variable. Since we
indicated that we wanted to parse the dates with the option
\sphinxcode{parse\_dates=True}, each row has its respective timestamp.  If, otherwise, we
were to ignore the dates, the result would be a integer-indexed dataset:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [25]: }\PYG{n}{data2}\PYG{p}{,} \PYG{n}{units} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{timeSeries}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{,} \PYG{n}{fconfig}\PYG{p}{,} \PYG{n}{parse\PYGZus{}dates}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}

\PYG{g+gp}{In [26]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{data2}\PYG{p}{)}
\PYG{g+go}{           u      v      w  theta\PYGZus{}v  mrho\PYGZus{}h2o  mrho\PYGZus{}co2       p  theta}
\PYG{g+go}{0      2.375 \PYGZhy{}5.206 \PYGZhy{}0.103    27.06      1238    14.675  99.190  30.43}
\PYG{g+go}{1      2.493 \PYGZhy{}5.098 \PYGZhy{}0.018    27.12      1196    14.409  99.199  30.43}
\PYG{g+go}{2      2.263 \PYGZhy{}5.114  0.014    27.11      1220    14.636  99.102  30.43}
\PYG{g+go}{3      2.210 \PYGZhy{}5.235 \PYGZhy{}0.012    27.11      1238    14.688  99.154  30.43}
\PYG{g+go}{4      2.158 \PYGZhy{}5.174 \PYGZhy{}0.112    27.12      1174    14.476  99.154  30.44}
\PYG{g+go}{5      2.334 \PYGZhy{}5.279 \PYGZhy{}0.092    27.10      1195    14.671  99.154  30.43}
\PYG{g+go}{6      2.396 \PYGZhy{}5.297  0.005    27.15      1198    14.669  99.154  30.43}
\PYG{g+go}{7      2.494 \PYGZhy{}5.246  0.039    27.13      1197    14.722  99.154  30.44}
\PYG{g+go}{8      2.263 \PYGZhy{}5.317 \PYGZhy{}0.079    27.12      1202    14.709  99.154  30.43}
\PYG{g+go}{9      2.135 \PYGZhy{}5.176 \PYGZhy{}0.036    27.08      1202    14.731  99.154  30.44}
\PYG{g+go}{...      ...    ...    ...      ...       ...       ...     ...    ...}
\PYG{g+go}{71990  4.951 \PYGZhy{}4.584  0.420    28.03      1261    14.772  99.102  32.08}
\PYG{g+go}{71991  5.057 \PYGZhy{}4.436  0.492    28.00      1181    14.718  99.138  32.07}
\PYG{g+go}{71992  5.145 \PYGZhy{}4.424  0.409    28.10      1216    14.889  99.112  32.08}
\PYG{g+go}{71993  5.282 \PYGZhy{}4.038  0.448    28.03      1198    14.485  99.112  32.06}
\PYG{g+go}{71994  5.065 \PYGZhy{}4.453  0.424    28.11      1184    14.578  99.138  32.07}
\PYG{g+go}{71995  5.262 \PYGZhy{}4.703  0.126    27.98      1264    14.929  99.138  32.08}
\PYG{g+go}{71996  5.323 \PYGZhy{}4.882  0.242    27.95      1229    14.258  99.138  32.07}
\PYG{g+go}{71997  5.344 \PYGZhy{}5.119  0.457    27.96      1198    14.962  99.102  32.07}
\PYG{g+go}{71998  5.281 \PYGZhy{}5.261  0.599    28.09      1231    14.615  99.112  32.07}
\PYG{g+go}{71999  5.235 \PYGZhy{}4.801  0.362    28.02      1211    14.682  99.164  32.08}

\PYG{g+go}{[72000 rows x 8 columns]}
\end{Verbatim}

And, as mentioned, the latter way is a lot faster:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [27]: }\PYG{o}{\PYGZpc{}}\PYG{k}{timeit} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{timeSeries}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{,} \PYG{n}{fconfig}\PYG{p}{,} \PYG{n}{parse\PYGZus{}dates}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+gp}{   ....: }\PYG{o}{\PYGZpc{}}\PYG{k}{timeit} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{timeSeries}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{,} \PYG{n}{fconfig}\PYG{p}{,} \PYG{n}{parse\PYGZus{}dates}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+gp}{   ....: }
\PYG{g+go}{1 loops, best of 3: 139 ms per loop}
\PYG{g+go}{1 loops, best of 3: 713 ms per loop}
\end{Verbatim}


\section{Viewing and manipulating data}
\label{basics:viewing-and-manipulating-data}
To view and manipulate data, mostly you have to follow Pandas's DataFrame rules. For
that we suggest that the user visit a Pandas tutorial. However, I'll explain
some main ideas here for the sake of completeness and introduce some few ideas specific
for Pymicra that don't exist for general Pandas DataFrames.


\subsection{Printing and plotting}
\label{basics:printing-and-plotting}
First, for viewing raw data on screen there's printing. Slicing and indexing
are supported by Pandas, but without support for units:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [29]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{theta\PYGZus{}v}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{Timestamp}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.000    27.06}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.050    27.12}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.100    27.11}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.150    27.11}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.200    27.12}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.250    27.10}
\PYG{g+go}{                           ...  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.700    28.11}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.750    27.98}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.800    27.95}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.850    27.96}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.900    28.09}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.950    28.02}
\PYG{g+go}{Name: theta\PYGZus{}v, dtype: float64}

\PYG{g+gp}{In [30]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{                             u      v      w}
\PYG{g+go}{Timestamp                                   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.000  2.375 \PYGZhy{}5.206 \PYGZhy{}0.103}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.050  2.493 \PYGZhy{}5.098 \PYGZhy{}0.018}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.100  2.263 \PYGZhy{}5.114  0.014}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.150  2.210 \PYGZhy{}5.235 \PYGZhy{}0.012}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.200  2.158 \PYGZhy{}5.174 \PYGZhy{}0.112}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.250  2.334 \PYGZhy{}5.279 \PYGZhy{}0.092}
\PYG{g+go}{...                        ...    ...    ...}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.700  5.065 \PYGZhy{}4.453  0.424}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.750  5.262 \PYGZhy{}4.703  0.126}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.800  5.323 \PYGZhy{}4.882  0.242}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.850  5.344 \PYGZhy{}5.119  0.457}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.900  5.281 \PYGZhy{}5.261  0.599}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.950  5.235 \PYGZhy{}4.801  0.362}

\PYG{g+go}{[72000 rows x 3 columns]}

\PYG{g+gp}{In [31]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{20131108 10:15:00.000}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{20131108 10:17:00.000}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{                             u      v      w  theta\PYGZus{}v  mrho\PYGZus{}h2o  mrho\PYGZus{}co2       p  theta}
\PYG{g+go}{Timestamp                                                                               }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.000  2.634 \PYGZhy{}4.351  0.107    27.30      1229    15.002  99.128  30.80}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.050  2.869 \PYGZhy{}4.249  0.040    27.44      1175    14.751  99.164  30.80}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.100  3.320 \PYGZhy{}4.326 \PYGZhy{}0.079    27.26      1159    14.689  99.138  30.80}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.150  2.759 \PYGZhy{}4.339 \PYGZhy{}0.007    27.24      1170    14.715  99.190  30.80}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.200  2.748 \PYGZhy{}4.128 \PYGZhy{}0.038    27.21      1174    14.681  99.190  30.80}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.250  3.149 \PYGZhy{}4.074 \PYGZhy{}0.387    27.20      1190    14.662  99.173  30.80}
\PYG{g+go}{...                        ...    ...    ...      ...       ...       ...     ...    ...}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:17:00.700  3.910 \PYGZhy{}4.698 \PYGZhy{}0.366    27.27      1170    14.592  99.128  30.85}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:17:00.750  3.824 \PYGZhy{}4.535 \PYGZhy{}0.313    27.33      1165    14.492  99.164  30.85}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:17:00.800  3.758 \PYGZhy{}4.353 \PYGZhy{}0.116    27.28      1103    14.495  99.164  30.85}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:17:00.850  3.761 \PYGZhy{}4.454 \PYGZhy{}0.010    27.28      1128    14.611  99.164  30.85}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:17:00.900  3.546 \PYGZhy{}4.766 \PYGZhy{}0.433    27.28      1131    14.709  99.147  30.85}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:17:00.950  3.238 \PYGZhy{}4.601 \PYGZhy{}0.378    27.29      1130    14.809  99.147  30.85}

\PYG{g+go}{[2420 rows x 8 columns]}
\end{Verbatim}

Note that Pandas ``guesses'' if the argument you pass (\sphinxcode{'theta\_v'} or
\sphinxcode{'2013-11-08 10:15:00'} etc.) is a column indexer or a row indexer. To use
these unambiguously, use the \sphinxcode{.loc} method as

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [32]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2013\PYGZhy{}11\PYGZhy{}08 10:17:00}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{                             u      v      w}
\PYG{g+go}{Timestamp                                   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.000  2.634 \PYGZhy{}4.351  0.107}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.050  2.869 \PYGZhy{}4.249  0.040}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.100  3.320 \PYGZhy{}4.326 \PYGZhy{}0.079}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.150  2.759 \PYGZhy{}4.339 \PYGZhy{}0.007}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.200  2.748 \PYGZhy{}4.128 \PYGZhy{}0.038}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.250  3.149 \PYGZhy{}4.074 \PYGZhy{}0.387}
\PYG{g+go}{...                        ...    ...    ...}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:17:00.700  3.910 \PYGZhy{}4.698 \PYGZhy{}0.366}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:17:00.750  3.824 \PYGZhy{}4.535 \PYGZhy{}0.313}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:17:00.800  3.758 \PYGZhy{}4.353 \PYGZhy{}0.116}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:17:00.850  3.761 \PYGZhy{}4.454 \PYGZhy{}0.010}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:17:00.900  3.546 \PYGZhy{}4.766 \PYGZhy{}0.433}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:17:00.950  3.238 \PYGZhy{}4.601 \PYGZhy{}0.378}

\PYG{g+go}{[2420 rows x 3 columns]}
\end{Verbatim}

This method is actually preferred  and you can find more information on this topic \href{http://pandas.pydata.org/pandas-docs/stable/indexing.html}{here}.

To view these data with units, you can use the \sphinxcode{.with\_units()} method.
The previous output would look like this using units:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [33]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{with\PYGZus{}units}\PYG{p}{(}\PYG{n}{units}\PYG{p}{)}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{theta\PYGZus{}v}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{                         \PYGZlt{}degC\PYGZgt{}}
\PYG{g+go}{Timestamp                      }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.000   27.06}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.050   27.12}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.100   27.11}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.150   27.11}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.200   27.12}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.250   27.10}
\PYG{g+go}{...                         ...}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.700   28.11}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.750   27.98}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.800   27.95}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.850   27.96}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.900   28.09}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.950   28.02}

\PYG{g+go}{[72000 rows x 1 columns]}

\PYG{g+gp}{In [34]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{with\PYGZus{}units}\PYG{p}{(}\PYG{n}{units}\PYG{p}{)}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{                                       u                v                w}
\PYG{g+go}{                        \PYGZlt{}meter / second\PYGZgt{} \PYGZlt{}meter / second\PYGZgt{} \PYGZlt{}meter / second\PYGZgt{}}
\PYG{g+go}{Timestamp                                                                 }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.000            2.375           \PYGZhy{}5.206           \PYGZhy{}0.103}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.050            2.493           \PYGZhy{}5.098           \PYGZhy{}0.018}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.100            2.263           \PYGZhy{}5.114            0.014}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.150            2.210           \PYGZhy{}5.235           \PYGZhy{}0.012}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.200            2.158           \PYGZhy{}5.174           \PYGZhy{}0.112}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.250            2.334           \PYGZhy{}5.279           \PYGZhy{}0.092}
\PYG{g+go}{...                                  ...              ...              ...}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.700            5.065           \PYGZhy{}4.453            0.424}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.750            5.262           \PYGZhy{}4.703            0.126}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.800            5.323           \PYGZhy{}4.882            0.242}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.850            5.344           \PYGZhy{}5.119            0.457}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.900            5.281           \PYGZhy{}5.261            0.599}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.950            5.235           \PYGZhy{}4.801            0.362}

\PYG{g+go}{[72000 rows x 3 columns]}

\PYG{g+gp}{In [35]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{with\PYGZus{}units}\PYG{p}{(}\PYG{n}{units}\PYG{p}{)}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{                                       u                v                w theta\PYGZus{}v  \PYGZbs{}}
\PYG{g+go}{                        \PYGZlt{}meter / second\PYGZgt{} \PYGZlt{}meter / second\PYGZgt{} \PYGZlt{}meter / second\PYGZgt{}  \PYGZlt{}degC\PYGZgt{}   }
\PYG{g+go}{Timestamp                                                                            }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.000            2.634           \PYGZhy{}4.351            0.107   27.30   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.050            2.869           \PYGZhy{}4.249            0.040   27.44   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.100            3.320           \PYGZhy{}4.326           \PYGZhy{}0.079   27.26   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.150            2.759           \PYGZhy{}4.339           \PYGZhy{}0.007   27.24   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.200            2.748           \PYGZhy{}4.128           \PYGZhy{}0.038   27.21   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.250            3.149           \PYGZhy{}4.074           \PYGZhy{}0.387   27.20   }
\PYG{g+go}{...                                  ...              ...              ...     ...   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.700            3.057           \PYGZhy{}4.090           \PYGZhy{}0.230   27.28   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.750            3.386           \PYGZhy{}4.169           \PYGZhy{}0.082   27.21   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.800            3.731           \PYGZhy{}4.180            0.291   27.42   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.850            3.676           \PYGZhy{}4.100            0.021   27.29   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.900            3.796           \PYGZhy{}4.390            0.170   27.24   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.950            3.294           \PYGZhy{}3.322            0.560   27.50   }

\PYG{g+go}{                                        mrho\PYGZus{}h2o                 mrho\PYGZus{}co2            p  theta  }
\PYG{g+go}{                        \PYGZlt{}millimole / meter ** 3\PYGZgt{} \PYGZlt{}millimole / meter ** 3\PYGZgt{} \PYGZlt{}kilopascal\PYGZgt{} \PYGZlt{}degC\PYGZgt{}  }
\PYG{g+go}{Timestamp                                                                                      }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.000                     1229                   15.002       99.128   30.8  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.050                     1175                   14.751       99.164   30.8  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.100                     1159                   14.689       99.138   30.8  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.150                     1170                   14.715       99.190   30.8  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.200                     1174                   14.681       99.190   30.8  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.250                     1190                   14.662       99.173   30.8  }
\PYG{g+go}{...                                          ...                      ...          ...    ...  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.700                     1151                   14.758       99.164   30.8  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.750                     1195                   14.318       99.164   30.8  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.800                     1172                   14.369       99.164   30.8  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.850                     1173                   14.687       99.164   30.8  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.900                     1153                   14.442       99.164   30.8  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:15:00.950                     1176                   14.724       99.208   30.8  }

\PYG{g+go}{[20 rows x 8 columns]}
\end{Verbatim}

\begin{notice}{warning}{Warning:}
Note that, although this method returns
a Pandas DataFrame, it is not meant for calculations. Currently the DataFrame it returns is meant for
visualization purposes only!
\end{notice}

We can also plot the data on screen so we can view it interactively. This can be done directly
from the DataFrame with

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [36]: }\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}

\PYG{g+gp}{In [37]: }\PYG{n}{data}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gh}{Out[37]: }\PYG{g+go}{\PYGZlt{}matplotlib.axes.\PYGZus{}subplots.AxesSubplot at 0x7f9b13847c50\PYGZgt{}}

\PYG{g+gp}{In [38]: }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\noindent\sphinxincludegraphics{{uvw_plot_basics}.png}

Using the \sphinxcode{plt.show()} command, the plot above would plot interactively. If
we had used \sphinxcode{plt.savefig('figure.png')} instead, it would have saved the
figure as png. For more on plotting, you can checkout Pandas's \href{http://pandas.pydata.org/pandas-docs/stable/visualization.html}{visualization
guide} and
find out ways to make this plot look nicer, how to render it with LaTeX and
some more tricks.

Pymicra also has an \sphinxcode{.xplot} method, which brings a little more options to
Pandas's \sphinxcode{.plot()} method.

\begin{notice}{note}{Todo}

give xplot examples
\end{notice}


\subsection{Converting units}
\label{basics:converting-units}
You can manually convert between units using the contents from \sphinxtitleref{Manipulating}
and the \href{https://pint.readthedocs.io/en/0.7.2/}{Pint} package. But Pymicra has a very useful method to do this called \sphinxcode{.convert\_cols} (more exist,
but let's focus on this one).

Let's, for example, convert some units:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [39]: }\PYG{n}{conversions} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{p}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pascal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mrho\PYGZus{}h2o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mole/m\PYGZca{}3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{theta\PYGZus{}v}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{kelvin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}

\PYG{g+gp}{In [40]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{convert\PYGZus{}cols}\PYG{p}{(}\PYG{n}{conversions}\PYG{p}{,} \PYG{n}{units}\PYG{p}{,} \PYG{n}{inplace\PYGZus{}units}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{(                             u      v      w  theta\PYGZus{}v  mrho\PYGZus{}h2o  mrho\PYGZus{}co2      p  theta}
\PYG{g+go}{Timestamp                                                                              }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.000  2.375 \PYGZhy{}5.206 \PYGZhy{}0.103   300.21     1.238    14.675  99190  30.43}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.050  2.493 \PYGZhy{}5.098 \PYGZhy{}0.018   300.27     1.196    14.409  99199  30.43}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.100  2.263 \PYGZhy{}5.114  0.014   300.26     1.220    14.636  99102  30.43}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.150  2.210 \PYGZhy{}5.235 \PYGZhy{}0.012   300.26     1.238    14.688  99154  30.43}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.200  2.158 \PYGZhy{}5.174 \PYGZhy{}0.112   300.27     1.174    14.476  99154  30.44}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.250  2.334 \PYGZhy{}5.279 \PYGZhy{}0.092   300.25     1.195    14.671  99154  30.43}
\PYG{g+go}{...                        ...    ...    ...      ...       ...       ...    ...    ...}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.700  5.065 \PYGZhy{}4.453  0.424   301.26     1.184    14.578  99138  32.07}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.750  5.262 \PYGZhy{}4.703  0.126   301.13     1.264    14.929  99138  32.08}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.800  5.323 \PYGZhy{}4.882  0.242   301.10     1.229    14.258  99138  32.07}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.850  5.344 \PYGZhy{}5.119  0.457   301.11     1.198    14.962  99102  32.07}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.900  5.281 \PYGZhy{}5.261  0.599   301.24     1.231    14.615  99112  32.07}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.950  5.235 \PYGZhy{}4.801  0.362   301.17     1.211    14.682  99164  32.08}

\PYG{g+go}{[72000 rows x 8 columns], \PYGZob{}\PYGZsq{}theta\PYGZus{}v\PYGZsq{}: \PYGZlt{}Unit(\PYGZsq{}kelvin\PYGZsq{})\PYGZgt{}, \PYGZsq{}p\PYGZsq{}: \PYGZlt{}Unit(\PYGZsq{}pascal\PYGZsq{})\PYGZgt{}, \PYGZsq{}mrho\PYGZus{}h2o\PYGZsq{}: \PYGZlt{}Unit(\PYGZsq{}mole / meter ** 3\PYGZsq{})\PYGZgt{}\PYGZcb{})}
\end{Verbatim}

Note that the units dictionary is updated automatically if the
\sphinxcode{inplace\_units} keyword is true. The default is false for safety reasons, but
passing this keyword as true is much simpler and compact:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [41]: }\PYG{n}{conversions} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{theta}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{kelvin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{theta\PYGZus{}v}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{kelvin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}

\PYG{g+gp}{In [42]: }\PYG{n}{data} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{convert\PYGZus{}cols}\PYG{p}{(}\PYG{n}{conversions}\PYG{p}{,} \PYG{n}{units}\PYG{p}{,} \PYG{n}{inplace\PYGZus{}units}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{g+gp}{In [43]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{with\PYGZus{}units}\PYG{p}{(}\PYG{n}{units}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{                                       u                v                w  theta\PYGZus{}v  \PYGZbs{}}
\PYG{g+go}{                        \PYGZlt{}meter / second\PYGZgt{} \PYGZlt{}meter / second\PYGZgt{} \PYGZlt{}meter / second\PYGZgt{} \PYGZlt{}kelvin\PYGZgt{}   }
\PYG{g+go}{Timestamp                                                                             }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.000            2.375           \PYGZhy{}5.206           \PYGZhy{}0.103   300.21   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.050            2.493           \PYGZhy{}5.098           \PYGZhy{}0.018   300.27   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.100            2.263           \PYGZhy{}5.114            0.014   300.26   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.150            2.210           \PYGZhy{}5.235           \PYGZhy{}0.012   300.26   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.200            2.158           \PYGZhy{}5.174           \PYGZhy{}0.112   300.27   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.250            2.334           \PYGZhy{}5.279           \PYGZhy{}0.092   300.25   }
\PYG{g+go}{...                                  ...              ...              ...      ...   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.700            5.065           \PYGZhy{}4.453            0.424   301.26   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.750            5.262           \PYGZhy{}4.703            0.126   301.13   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.800            5.323           \PYGZhy{}4.882            0.242   301.10   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.850            5.344           \PYGZhy{}5.119            0.457   301.11   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.900            5.281           \PYGZhy{}5.261            0.599   301.24   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.950            5.235           \PYGZhy{}4.801            0.362   301.17   }

\PYG{g+go}{                                        mrho\PYGZus{}h2o                 mrho\PYGZus{}co2            p    theta  }
\PYG{g+go}{                        \PYGZlt{}millimole / meter ** 3\PYGZgt{} \PYGZlt{}millimole / meter ** 3\PYGZgt{} \PYGZlt{}kilopascal\PYGZgt{} \PYGZlt{}kelvin\PYGZgt{}  }
\PYG{g+go}{Timestamp                                                                                        }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.000                     1238                   14.675       99.190   303.58  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.050                     1196                   14.409       99.199   303.58  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.100                     1220                   14.636       99.102   303.58  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.150                     1238                   14.688       99.154   303.58  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.200                     1174                   14.476       99.154   303.59  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.250                     1195                   14.671       99.154   303.58  }
\PYG{g+go}{...                                          ...                      ...          ...      ...  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.700                     1184                   14.578       99.138   305.22  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.750                     1264                   14.929       99.138   305.23  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.800                     1229                   14.258       99.138   305.22  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.850                     1198                   14.962       99.102   305.22  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.900                     1231                   14.615       99.112   305.22  }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.950                     1211                   14.682       99.164   305.23  }

\PYG{g+go}{[72000 rows x 8 columns]}
\end{Verbatim}


\subsection{Manipulating}
\label{basics:manipulating}
Manipulating data is pretty intuitive with Pandas. For example

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [44]: }\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rho\PYGZus{}air}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{p}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mf}{287.058}\PYG{o}{*}\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{theta\PYGZus{}v}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{g+gp}{In [45]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rho\PYGZus{}air}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{Timestamp}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.000    0.001151}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.050    0.001151}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.100    0.001150}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.150    0.001150}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.200    0.001150}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:00:00.250    0.001150}
\PYG{g+go}{                             ...   }
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.700    0.001146}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.750    0.001147}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.800    0.001147}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.850    0.001147}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.900    0.001146}
\PYG{g+go}{2013\PYGZhy{}11\PYGZhy{}08 10:59:59.950    0.001147}
\PYG{g+go}{Name: rho\PYGZus{}air, dtype: float64}
\end{Verbatim}

If, however, you're not familiar with Pandas and prefer to just stick with what
you know, you can get \href{http://www.numpy.org/}{Numpy} arrays from columns using the \sphinxcode{.values}
attribute:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [46]: }\PYG{n}{P} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{p}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}

\PYG{g+gp}{In [47]: }\PYG{n}{Tv} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{theta\PYGZus{}v}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}

\PYG{g+gp}{In [48]: }\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{Tv}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{\PYGZlt{}type \PYGZsq{}numpy.ndarray\PYGZsq{}\PYGZgt{}}

\PYG{g+gp}{In [49]: }\PYG{n}{rho\PYGZus{}air} \PYG{o}{=} \PYG{n}{P}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mf}{287.058}\PYG{o}{*}\PYG{n}{Tv}\PYG{p}{)}

\PYG{g+gp}{In [50]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{rho\PYGZus{}air}\PYG{p}{)}
\PYG{g+go}{[ 0.00115099  0.00115087  0.00114978 ...,  0.00114654  0.00114616}
\PYG{g+go}{  0.00114702]}

\PYG{g+gp}{In [51]: }\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{rho\PYGZus{}air}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{\PYGZlt{}type \PYGZsq{}numpy.ndarray\PYGZsq{}\PYGZgt{}}
\end{Verbatim}

Doing that you can step out of Pandas and do your own calculations using your
own Python or Numpy code. This is pretty advantageous if you have a lot of routines
that are already written in your own way.


\chapter{Hands-on tutorial}
\label{tutorial::doc}\label{tutorial:hands-on-tutorial}
Here we give some examples of generally-used steps to obtain fluxes, spectra
and Ogives. This is just the commonly done procedures, but more can (and
sometimes should) be done depending on the data.


\section{Calculating auxiliary variables and units}
\label{tutorial:calculating-auxiliary-variables-and-units}
After reading the data it's easy to rotate the coordinates. Currently, only the
2D rotation is implemented. But in the future more will come (you can
contribute with another one yourself!).  To rotate, use the \sphinxcode{pm.rotateCoor}
function:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [1]: }\PYG{k+kn}{import} \PYG{n+nn}{pymicra} \PYG{k+kn}{as} \PYG{n+nn}{pm}

\PYG{g+gp}{In [2]: }\PYG{n}{fname} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../examples/ex\PYGZus{}data/20131108\PYGZhy{}1000.csv}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{g+gp}{In [3]: }\PYG{n}{fconfig} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{fileConfig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../examples/lake.config}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{g+gp}{In [4]: }\PYG{n}{data}\PYG{p}{,} \PYG{n}{units} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{timeSeries}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{,} \PYG{n}{fconfig}\PYG{p}{,} \PYG{n}{parse\PYGZus{}dates}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{g+gp}{In [5]: }\PYG{n}{data} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{rotateCoor}\PYG{p}{(}\PYG{n}{how}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{g+gp}{In [6]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{with\PYGZus{}units}\PYG{p}{(}\PYG{n}{units}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{u         \PYGZlt{}meter / second\PYGZgt{}            6.021737e+00}
\PYG{g+go}{v         \PYGZlt{}meter / second\PYGZgt{}            2.271683e\PYGZhy{}14}
\PYG{g+go}{w         \PYGZlt{}meter / second\PYGZgt{}            1.178001e\PYGZhy{}16}
\PYG{g+go}{theta\PYGZus{}v   \PYGZlt{}degC\PYGZgt{}                      2.764434e+01}
\PYG{g+go}{mrho\PYGZus{}h2o  \PYGZlt{}millimole / meter ** 3\PYGZgt{}    1.169865e+03}
\PYG{g+go}{mrho\PYGZus{}co2  \PYGZlt{}millimole / meter ** 3\PYGZgt{}    1.466232e+01}
\PYG{g+go}{p         \PYGZlt{}kilopascal\PYGZgt{}                9.913677e+01}
\PYG{g+go}{theta     \PYGZlt{}degC\PYGZgt{}                      3.127128e+01}
\PYG{g+go}{dtype: float64}
\end{Verbatim}

As you can see, the u, v, w components have been rotated and \sphinxcode{v} and \sphinxcode{w}
mean are zero.

Pymicra has a very useful function called \sphinxcode{preProcess} which ``expands'' the
variables in the dataset by using the original variables to calculate new ones,
such as mixing ratios, moist and dry air densities etc. In the process some
units are also converted, such as temperature units, which are converted to
Kelvin, if they are in Celsius. The \sphinxcode{preProcess} function has some options to
calculate some variables in determined ways and is very ``verbose'', so as to
show the user exactly what it is doing:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [7]: }\PYG{n}{data} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{preProcess}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{units}\PYG{p}{,} \PYG{n}{expand\PYGZus{}temperature}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,}
\PYG{g+gp}{   ...: }    \PYG{n}{use\PYGZus{}means}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{n}{rho\PYGZus{}air\PYGZus{}from\PYGZus{}theta\PYGZus{}v}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{solutes}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{co2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{   ...: }
\PYG{g+go}{Beginning of pre\PYGZhy{}processing ...}
\PYG{g+go}{Converting theta\PYGZus{}v and theta to kelvin ... Done!}
\PYG{g+go}{Didn\PYGZsq{}t locate mass density of h2o. Trying to calculate it ... Done!}
\PYG{g+go}{Moist air density not present in dataset}
\PYG{g+go}{Calculating rho\PYGZus{}air = p/(Rdry * theta\PYGZus{}v) ... Done!}
\PYG{g+go}{Calculating dry\PYGZus{}air mass\PYGZus{}density = rho\PYGZus{}air \PYGZhy{} rho\PYGZus{}h2o ... Done!}
\PYG{g+go}{Dry air molar density not in dataset}
\PYG{g+go}{Calculating dry\PYGZus{}air molar\PYGZus{}density = rho\PYGZus{}dry / dry\PYGZus{}air\PYGZus{}molar\PYGZus{}mass ... Done!}
\PYG{g+go}{Calculating specific humidity = rho\PYGZus{}h2o / rho\PYGZus{}air ... Done!}
\PYG{g+go}{Calculating h2o mass mixing ratio = rho\PYGZus{}h2o / rho\PYGZus{}dry ... Done!}
\PYG{g+go}{Calculating h2o molar mixing ratio = rho\PYGZus{}h2o / rho\PYGZus{}dry ... Done!}
\PYG{g+go}{Didn\PYGZsq{}t locate mass density of co2. Trying to calculate it ... Done!}
\PYG{g+go}{Calculating co2 mass concentration (g/g) = rho\PYGZus{}co2 / rho\PYGZus{}air ... Done!}
\PYG{g+go}{Calculating co2 mass mixing ratio = rho\PYGZus{}co2 / rho\PYGZus{}dry ... Done!}
\PYG{g+go}{Calculating co2 molar mixing ratio = mrho\PYGZus{}co2 / mrho\PYGZus{}dry ... Done!}
\PYG{g+go}{Pre\PYGZhy{}processing complete.}


\PYG{g+gp}{In [8]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{with\PYGZus{}units}\PYG{p}{(}\PYG{n}{units}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{u         \PYGZlt{}meter / second\PYGZgt{}            6.021737e+00}
\PYG{g+go}{v         \PYGZlt{}meter / second\PYGZgt{}            2.271683e\PYGZhy{}14}
\PYG{g+go}{w         \PYGZlt{}meter / second\PYGZgt{}            1.178001e\PYGZhy{}16}
\PYG{g+go}{theta\PYGZus{}v   \PYGZlt{}kelvin\PYGZgt{}                    3.007943e+02}
\PYG{g+go}{mrho\PYGZus{}h2o  \PYGZlt{}millimole / meter ** 3\PYGZgt{}    1.169865e+03}
\PYG{g+go}{mrho\PYGZus{}co2  \PYGZlt{}millimole / meter ** 3\PYGZgt{}    1.466232e+01}
\PYG{g+go}{p         \PYGZlt{}kilopascal\PYGZgt{}                9.913677e+01}
\PYG{g+go}{theta     \PYGZlt{}kelvin\PYGZgt{}                    3.044213e+02}
\PYG{g+go}{rho\PYGZus{}h2o   \PYGZlt{}kilogram / meter ** 3\PYGZgt{}     2.107547e\PYGZhy{}02}
\PYG{g+go}{rho\PYGZus{}air   \PYGZlt{}kilogram / meter ** 3\PYGZgt{}     1.148149e+00}
\PYG{g+go}{rho\PYGZus{}dry   \PYGZlt{}kilogram / meter ** 3\PYGZgt{}     1.127073e+00}
\PYG{g+go}{mrho\PYGZus{}dry  \PYGZlt{}mole / meter ** 3\PYGZgt{}         3.891223e+01}
\PYG{g+go}{q         \PYGZlt{}dimensionless\PYGZgt{}             1.835686e\PYGZhy{}02}
\PYG{g+go}{r\PYGZus{}h2o     \PYGZlt{}dimensionless\PYGZgt{}             1.870102e\PYGZhy{}02}
\PYG{g+go}{mr\PYGZus{}h2o    \PYGZlt{}dimensionless\PYGZgt{}             3.006698e\PYGZhy{}02}
\PYG{g+go}{rho\PYGZus{}co2   \PYGZlt{}kilogram / meter ** 3\PYGZgt{}     6.452812e\PYGZhy{}04}
\PYG{g+go}{conc\PYGZus{}co2  \PYGZlt{}dimensionless\PYGZgt{}             5.620179e\PYGZhy{}04}
\PYG{g+go}{r\PYGZus{}co2     \PYGZlt{}dimensionless\PYGZgt{}             5.725280e\PYGZhy{}04}
\PYG{g+go}{mr\PYGZus{}co2    \PYGZlt{}dimensionless\PYGZgt{}             3.768047e\PYGZhy{}04}
\PYG{g+go}{dtype: float64}
\end{Verbatim}

Note that our dataset now has many other variables and that the temperatures
are now in Kelvin. Note also that you must, at this point, specify which
solutes you wish to consider. The only solute that Pymicra looks for by default
is water vapor.

It is recommended that you carefully observe the output of \sphinxcode{preProcess} to
see if it's doing what you think it's doing and to analyse its calculation
logic. By doing that you can have a better idea of what it does without having
to check the code, and how to prevent it from doing some calculations you don't
want. For example, if you're not happy with the way it calculates moist air
density, you can calculate it yourself by extracting {\color{red}\bfseries{}Numpy\_} arrays using the
\sphinxcode{.values} method:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{T} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{theta}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}
\PYG{n}{P} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{p}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}
\PYG{n}{water\PYGZus{}density} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mrho\PYGZus{}h2o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}
\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rho\PYGZus{}air}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{my\PYGZus{}rho\PYGZus{}air\PYGZus{}calculation}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,} \PYG{n}{P}\PYG{p}{,} \PYG{n}{water\PYGZus{}density}\PYG{p}{)}
\end{Verbatim}

Next we calculate the fluctuations. The way to do that is with the \sphinxcode{detrend()}
function/method.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [9]: }\PYG{n}{ddata} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{detrend}\PYG{p}{(}\PYG{n}{how}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{linear}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{units}\PYG{o}{=}\PYG{n}{units}\PYG{p}{,} \PYG{n}{ignore}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{p}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{theta}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{g+gp}{In [10]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{ddata}\PYG{o}{.}\PYG{n}{with\PYGZus{}units}\PYG{p}{(}\PYG{n}{units}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{u\PYGZsq{}         \PYGZlt{}meter / second\PYGZgt{}           \PYGZhy{}3.217650e\PYGZhy{}05}
\PYG{g+go}{v\PYGZsq{}         \PYGZlt{}meter / second\PYGZgt{}           \PYGZhy{}4.224175e\PYGZhy{}05}
\PYG{g+go}{w\PYGZsq{}         \PYGZlt{}meter / second\PYGZgt{}           \PYGZhy{}4.156934e\PYGZhy{}06}
\PYG{g+go}{theta\PYGZus{}v\PYGZsq{}   \PYGZlt{}kelvin\PYGZgt{}                   \PYGZhy{}3.421680e\PYGZhy{}05}
\PYG{g+go}{mrho\PYGZus{}h2o\PYGZsq{}  \PYGZlt{}millimole / meter ** 3\PYGZgt{}   \PYGZhy{}7.917622e\PYGZhy{}04}
\PYG{g+go}{mrho\PYGZus{}co2\PYGZsq{}  \PYGZlt{}millimole / meter ** 3\PYGZgt{}    2.996904e\PYGZhy{}06}
\PYG{g+go}{rho\PYGZus{}h2o\PYGZsq{}   \PYGZlt{}kilogram / meter ** 3\PYGZgt{}    \PYGZhy{}1.426702e\PYGZhy{}08}
\PYG{g+go}{rho\PYGZus{}air\PYGZsq{}   \PYGZlt{}kilogram / meter ** 3\PYGZgt{}     1.506704e\PYGZhy{}07}
\PYG{g+go}{rho\PYGZus{}dry\PYGZsq{}   \PYGZlt{}kilogram / meter ** 3\PYGZgt{}     1.648373e\PYGZhy{}07}
\PYG{g+go}{mrho\PYGZus{}dry\PYGZsq{}  \PYGZlt{}mole / meter ** 3\PYGZgt{}         5.689934e\PYGZhy{}06}
\PYG{g+go}{q\PYGZsq{}         \PYGZlt{}dimensionless\PYGZgt{}            \PYGZhy{}1.480115e\PYGZhy{}08}
\PYG{g+go}{r\PYGZus{}h2o\PYGZsq{}     \PYGZlt{}dimensionless\PYGZgt{}            \PYGZhy{}1.535592e\PYGZhy{}08}
\PYG{g+go}{mr\PYGZus{}h2o\PYGZsq{}    \PYGZlt{}dimensionless\PYGZgt{}            \PYGZhy{}2.468290e\PYGZhy{}08}
\PYG{g+go}{rho\PYGZus{}co2\PYGZsq{}   \PYGZlt{}kilogram / meter ** 3\PYGZgt{}     1.318839e\PYGZhy{}10}
\PYG{g+go}{conc\PYGZus{}co2\PYGZsq{}  \PYGZlt{}dimensionless\PYGZgt{}             4.107355e\PYGZhy{}11}
\PYG{g+go}{r\PYGZus{}co2\PYGZsq{}     \PYGZlt{}dimensionless\PYGZgt{}             3.319263e\PYGZhy{}11}
\PYG{g+go}{mr\PYGZus{}co2\PYGZsq{}    \PYGZlt{}dimensionless\PYGZgt{}             2.184087e\PYGZhy{}11}
\PYG{g+go}{dtype: float64}
\end{Verbatim}

Note the \sphinxcode{ignore} keyword with which you can pass which variables you don't
want fluctuations of. In our case both the pressure fluctuations and the
thermodynamic temperature (measured with the LI7500 and the datalogger's
internal thermometer) can't be properly measured with the sensors used. Passing
these variables as ignored will prevent Pymicra from calculating these
fluctuations, which later on prevents it from inadvertently using the
fluctuations of these variables with these sensors when calculating fluxes.
\sphinxcode{theta} fluctuations will instead be calculated with virtual temperature
fluctuations and pressure fluctuations are generally not used.

The \sphinxcode{how} keyword supports \sphinxcode{'linear'}, \sphinxcode{'movingmean'},
\sphinxcode{'movingmedian'}, \sphinxcode{'block'} and \sphinxcode{'poly'}.  Each of those (with the
exception of \sphinxcode{'block'} and \sphinxcode{'linear'}) are passed to Pandas or Numpy
(\sphinxcode{pandas.rolling\_mean}, \sphinxcode{pandas.rolling\_median} and \sphinxcode{numpy.polyfit}) and
support their respective keywords, such as \sphinxcode{data.detrend(how='movingmedian',
units=units, ignore={[}'theta', 'p'{]}), min\_periods=1)} to determine the minimum
number of observations in window required to have a value.

Now we must expand our dataset with the fluctuations by \href{http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.join.html}{joining DataFrames}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [11]: }\PYG{n}{data} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{ddata}\PYG{p}{)}

\PYG{g+gp}{In [12]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{with\PYGZus{}units}\PYG{p}{(}\PYG{n}{units}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{u          \PYGZlt{}meter / second\PYGZgt{}            6.021737e+00}
\PYG{g+go}{v          \PYGZlt{}meter / second\PYGZgt{}            2.271683e\PYGZhy{}14}
\PYG{g+go}{w          \PYGZlt{}meter / second\PYGZgt{}            1.178001e\PYGZhy{}16}
\PYG{g+go}{theta\PYGZus{}v    \PYGZlt{}kelvin\PYGZgt{}                    3.007943e+02}
\PYG{g+go}{mrho\PYGZus{}h2o   \PYGZlt{}millimole / meter ** 3\PYGZgt{}    1.169865e+03}
\PYG{g+go}{mrho\PYGZus{}co2   \PYGZlt{}millimole / meter ** 3\PYGZgt{}    1.466232e+01}
\PYG{g+go}{p          \PYGZlt{}kilopascal\PYGZgt{}                9.913677e+01}
\PYG{g+go}{theta      \PYGZlt{}kelvin\PYGZgt{}                    3.044213e+02}
\PYG{g+go}{rho\PYGZus{}h2o    \PYGZlt{}kilogram / meter ** 3\PYGZgt{}     2.107547e\PYGZhy{}02}
\PYG{g+go}{rho\PYGZus{}air    \PYGZlt{}kilogram / meter ** 3\PYGZgt{}     1.148149e+00}
\PYG{g+go}{rho\PYGZus{}dry    \PYGZlt{}kilogram / meter ** 3\PYGZgt{}     1.127073e+00}
\PYG{g+go}{mrho\PYGZus{}dry   \PYGZlt{}mole / meter ** 3\PYGZgt{}         3.891223e+01}
\PYG{g+go}{q          \PYGZlt{}dimensionless\PYGZgt{}             1.835686e\PYGZhy{}02}
\PYG{g+go}{r\PYGZus{}h2o      \PYGZlt{}dimensionless\PYGZgt{}             1.870102e\PYGZhy{}02}
\PYG{g+go}{mr\PYGZus{}h2o     \PYGZlt{}dimensionless\PYGZgt{}             3.006698e\PYGZhy{}02}
\PYG{g+go}{                                           ...     }
\PYG{g+go}{w\PYGZsq{}         \PYGZlt{}meter / second\PYGZgt{}           \PYGZhy{}4.156934e\PYGZhy{}06}
\PYG{g+go}{theta\PYGZus{}v\PYGZsq{}   \PYGZlt{}kelvin\PYGZgt{}                   \PYGZhy{}3.421680e\PYGZhy{}05}
\PYG{g+go}{mrho\PYGZus{}h2o\PYGZsq{}  \PYGZlt{}millimole / meter ** 3\PYGZgt{}   \PYGZhy{}7.917622e\PYGZhy{}04}
\PYG{g+go}{mrho\PYGZus{}co2\PYGZsq{}  \PYGZlt{}millimole / meter ** 3\PYGZgt{}    2.996904e\PYGZhy{}06}
\PYG{g+go}{rho\PYGZus{}h2o\PYGZsq{}   \PYGZlt{}kilogram / meter ** 3\PYGZgt{}    \PYGZhy{}1.426702e\PYGZhy{}08}
\PYG{g+go}{rho\PYGZus{}air\PYGZsq{}   \PYGZlt{}kilogram / meter ** 3\PYGZgt{}     1.506704e\PYGZhy{}07}
\PYG{g+go}{rho\PYGZus{}dry\PYGZsq{}   \PYGZlt{}kilogram / meter ** 3\PYGZgt{}     1.648373e\PYGZhy{}07}
\PYG{g+go}{mrho\PYGZus{}dry\PYGZsq{}  \PYGZlt{}mole / meter ** 3\PYGZgt{}         5.689934e\PYGZhy{}06}
\PYG{g+go}{q\PYGZsq{}         \PYGZlt{}dimensionless\PYGZgt{}            \PYGZhy{}1.480115e\PYGZhy{}08}
\PYG{g+go}{r\PYGZus{}h2o\PYGZsq{}     \PYGZlt{}dimensionless\PYGZgt{}            \PYGZhy{}1.535592e\PYGZhy{}08}
\PYG{g+go}{mr\PYGZus{}h2o\PYGZsq{}    \PYGZlt{}dimensionless\PYGZgt{}            \PYGZhy{}2.468290e\PYGZhy{}08}
\PYG{g+go}{rho\PYGZus{}co2\PYGZsq{}   \PYGZlt{}kilogram / meter ** 3\PYGZgt{}     1.318839e\PYGZhy{}10}
\PYG{g+go}{conc\PYGZus{}co2\PYGZsq{}  \PYGZlt{}dimensionless\PYGZgt{}             4.107355e\PYGZhy{}11}
\PYG{g+go}{r\PYGZus{}co2\PYGZsq{}     \PYGZlt{}dimensionless\PYGZgt{}             3.319263e\PYGZhy{}11}
\PYG{g+go}{mr\PYGZus{}co2\PYGZsq{}    \PYGZlt{}dimensionless\PYGZgt{}             2.184087e\PYGZhy{}11}
\PYG{g+go}{dtype: float64}
\end{Verbatim}


\section{Creating a site configuration file}
\label{tutorial:creating-a-site-configuration-file}
In order to use some micrometeorological function, we need a site configuration
object, or site object. This object tells Pymicra how the instruments are organized
and how is experimental site (vegetation, roughness length etc.). This object is created
with the \sphinxcode{siteConfig()} call and the easiest way is to use it with a site config file. This
is like a \sphinxcode{fileConfig} file, but simpler and for the micrometeorological aspects of the site.
Consider this example of a site config file, saved at \sphinxcode{../examples/lake.site}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{description}         \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Site configurations for the lake island}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n}{measurement\PYGZus{}height}  \PYG{o}{=} \PYG{l+m+mf}{2.75}  \PYG{c+c1}{\PYGZsh{} m}
\PYG{n}{canopy\PYGZus{}height}       \PYG{o}{=} \PYG{l+m+mf}{0.1}   \PYG{c+c1}{\PYGZsh{} m}
\PYG{n}{displacement\PYGZus{}height} \PYG{o}{=} \PYG{l+m+mf}{0.05}  \PYG{c+c1}{\PYGZsh{} m}
\PYG{n}{roughness\PYGZus{}length}    \PYG{o}{=} \PYG{o}{.}\PYG{l+m+mi}{01}   \PYG{c+c1}{\PYGZsh{} m}
\end{Verbatim}

As in the case of \sphinxcode{fileConfig}, the description is optional, but is handy for
organization purposes and printing on screen.

The \sphinxcode{measurement\_height} keyword is the general measurement height to be used
in the calculation, generally taken as the sonic anemometer height (in meters).

The \sphinxcode{canopy\_height} keyword is what it sounds like. Should be the mean canopy
height in meters. The \sphinxcode{displacement\_height} is the zero-plane displacement
height. If it is not given, it'll be calculated as 2/3 of the mean canopy
height.

The \sphinxcode{roughness\_length} is the roughness length in meters.

The creation of the site config object is done as

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [13]: }\PYG{n}{siteconf} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{siteConfig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../examples/lake.site}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{g+gp}{In [14]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{siteconf}\PYG{p}{)}
\PYG{g+go}{\PYGZlt{}pymicra.siteConfig\PYGZgt{} object}
\PYG{g+go}{Site configurations for the lake island}
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{altitude}               \PYG{n+nb+bp}{None}
\PYG{n}{canopy\PYGZus{}height}           \PYG{l+m+mf}{0.1}
\PYG{n}{displacement\PYGZus{}height}    \PYG{l+m+mf}{0.05}
\PYG{n}{from\PYGZus{}file}              \PYG{n+nb+bp}{None}
\PYG{n}{instruments\PYGZus{}height}     \PYG{n+nb+bp}{None}
\PYG{n}{latitude}               \PYG{n+nb+bp}{None}
\PYG{n}{longitude}              \PYG{n+nb+bp}{None}
\PYG{n}{measurement\PYGZus{}height}     \PYG{l+m+mf}{2.75}
\PYG{n}{roughness\PYGZus{}length}       \PYG{l+m+mf}{0.01}
\PYG{n+ne}{dtype}: object
\end{Verbatim}


\section{Extracting fluxes}
\label{tutorial:extracting-fluxes}
Finally, we are able to calculate the fluxes and turbulent scales. For that we
use the \sphinxcode{eddyCovariance} function along with the \sphinxcode{get\_turbulent\_scales}
keyword (which is true by default). Again, it is recommended that you carefully
check the output of this function before moving on:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [15]: }\PYG{n}{results} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{eddyCovariance}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{units}\PYG{p}{,} \PYG{n}{site\PYGZus{}config}\PYG{o}{=}\PYG{n}{siteconf}\PYG{p}{,}
\PYG{g+gp}{   ....: }    \PYG{n}{get\PYGZus{}turbulent\PYGZus{}scales}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{wpl}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{solutes}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{co2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{   ....: }
\PYG{g+go}{Beginning Eddy Covariance method...}
\PYG{g+go}{Fluctuations of theta not found. Will try to calculate it with theta\PYGZsq{} = (theta\PYGZus{}v\PYGZsq{} \PYGZhy{} 0.61 theta\PYGZus{}mean q\PYGZsq{})/(1 + 0.61 q\PYGZus{}mean ... done!}
\PYG{g+go}{Calculating fluxes from covariances ... done!}
\PYG{g+go}{Applying WPL correction for water vapor flux ... done!}
\PYG{g+go}{Applying WPL correction for latent heat flux using result for water vapor flux ... done!}
\PYG{g+go}{Re\PYGZhy{}calculating cov(mrho\PYGZus{}h2o\PYGZsq{}, w\PYGZsq{}) according to WPL correction ... done!}
\PYG{g+go}{Applying WPL correction for F\PYGZus{}co2 ... done!}
\PYG{g+go}{Re\PYGZhy{}calculating cov(mrho\PYGZus{}co2\PYGZsq{}, w\PYGZsq{}) according to WPL correction ... done!}
\PYG{g+go}{Beginning to extract turbulent scales...}
\PYG{g+go}{Data seems to be covariances. Will it use as covariances ...}
\PYG{g+go}{Calculating the turbulent scales of wind, temperature and humidity ... done!}
\PYG{g+go}{Calculating the turbulent scale of co2 ... done!}
\PYG{g+go}{Calculating Obukhov length and stability parameter ... done!}
\PYG{g+go}{Calculating turbulent scales of mass concentration ... done!}
\PYG{g+go}{Done with Eddy Covariance.}


\PYG{g+gp}{In [16]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{results}\PYG{o}{.}\PYG{n}{with\PYGZus{}units}\PYG{p}{(}\PYG{n}{units}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{tau            \PYGZlt{}kilogram / meter / second ** 2\PYGZgt{}     1.957307e\PYGZhy{}01}
\PYG{g+go}{H              \PYGZlt{}watt / meter ** 2\PYGZgt{}                  5.083720e+01}
\PYG{g+go}{Hv             \PYGZlt{}watt / meter ** 2\PYGZgt{}                  7.453761e+01}
\PYG{g+go}{E              \PYGZlt{}millimole / meter ** 2 / second\PYGZgt{}    7.007486e+00}
\PYG{g+go}{LE             \PYGZlt{}watt / meter ** 2\PYGZgt{}                  3.063926e+02}
\PYG{g+go}{F\PYGZus{}co2          \PYGZlt{}millimole / meter ** 2 / second\PYGZgt{}    2.648931e\PYGZhy{}04}
\PYG{g+go}{u\PYGZus{}star         \PYGZlt{}meter / second\PYGZgt{}                     4.128863e\PYGZhy{}01}
\PYG{g+go}{theta\PYGZus{}v\PYGZus{}star   \PYGZlt{}kelvin\PYGZgt{}                             1.566857e\PYGZhy{}01}
\PYG{g+go}{theta\PYGZus{}star     \PYGZlt{}kelvin\PYGZgt{}                             1.068650e\PYGZhy{}01}
\PYG{g+go}{mrho\PYGZus{}h2o\PYGZus{}star  \PYGZlt{}millimole / meter ** 3\PYGZgt{}             1.697195e+01}
\PYG{g+go}{mrho\PYGZus{}co2\PYGZus{}star  \PYGZlt{}millimole / meter ** 3\PYGZgt{}             6.415643e\PYGZhy{}04}
\PYG{g+go}{Lo             \PYGZlt{}meter\PYGZgt{}                             \PYGZhy{}8.342964e+01}
\PYG{g+go}{zeta           \PYGZlt{}dimensionless\PYGZgt{}                     \PYGZhy{}3.236260e\PYGZhy{}02}
\PYG{g+go}{q\PYGZus{}star         \PYGZlt{}dimensionless\PYGZgt{}                      2.663024e\PYGZhy{}04}
\PYG{g+go}{conc\PYGZus{}co2\PYGZus{}star  \PYGZlt{}dimensionless\PYGZgt{}                      2.459169e\PYGZhy{}08}
\PYG{g+go}{dtype: float64}
\end{Verbatim}

Note that once more we must list the solutes available.

Note also that the \sphinxcode{units} dictionary is automatically updated at with every
function and method with the new variables created and their units! That way if
you're in doubt of which unit the outputs are coming, just check \sphinxcode{units}
directly or with the \sphinxcode{.with\_units()} method.

Check out the example to get fluxes of many files \href{https://github.com/tomchor/pymicra/tree/master/examples/get\_fluxes.py}{here} and
download the example data \href{https://github.com/tomchor/pymicra/tree/master/examples/ex\_data}{here}.

The output of this file is

\begin{Verbatim}[commandchars=\\\{\}]
                                                 \PYG{n}{tau}                   \PYG{n}{H}                  \PYG{n}{Hv}                                 \PYG{n}{E}                  \PYG{n}{LE}  \PYGZbs{}
                    \PYG{o}{\PYGZlt{}}\PYG{n}{kilogram} \PYG{o}{/} \PYG{n}{meter} \PYG{o}{/} \PYG{n}{second} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{watt} \PYG{o}{/} \PYG{n}{meter} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{watt} \PYG{o}{/} \PYG{n}{meter} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{millimole} \PYG{o}{/} \PYG{n}{meter} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{/} \PYG{n}{second}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{watt} \PYG{o}{/} \PYG{n}{meter} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08} \PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mo}{00}\PYG{p}{:}\PYG{l+m+mo}{00}                         \PYG{l+m+mf}{0.195731}           \PYG{l+m+mf}{50.837195}           \PYG{l+m+mf}{74.537609}                          \PYG{l+m+mf}{7.007486}          \PYG{l+m+mf}{306.392623}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08} \PYG{l+m+mi}{12}\PYG{p}{:}\PYG{l+m+mo}{00}\PYG{p}{:}\PYG{l+m+mo}{00}                         \PYG{l+m+mf}{0.070182}           \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.116972}           \PYG{l+m+mf}{14.737946}                          \PYG{l+m+mf}{6.647450}          \PYG{l+m+mf}{290.331014}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08} \PYG{l+m+mi}{13}\PYG{p}{:}\PYG{l+m+mo}{00}\PYG{p}{:}\PYG{l+m+mo}{00}                         \PYG{l+m+mf}{0.059115}           \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.325774}           \PYG{l+m+mf}{12.743194}                          \PYG{l+m+mf}{4.875838}          \PYG{l+m+mf}{212.906974}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mo}{00}\PYG{p}{:}\PYG{l+m+mo}{00}                         \PYG{l+m+mf}{0.017075}          \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{13.847040}           \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.131275}                          \PYG{l+m+mf}{2.961474}          \PYG{l+m+mf}{128.982980}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08} \PYG{l+m+mi}{17}\PYG{p}{:}\PYG{l+m+mo}{00}\PYG{p}{:}\PYG{l+m+mo}{00}                         \PYG{l+m+mf}{0.003284}           \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.557620}           \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.525949}                          \PYG{l+m+mf}{0.931213}           \PYG{l+m+mf}{40.576805}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08} \PYG{l+m+mi}{18}\PYG{p}{:}\PYG{l+m+mo}{00}\PYG{p}{:}\PYG{l+m+mo}{00}                         \PYG{l+m+mf}{0.026564}           \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.632330}           \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.782190}                          \PYG{l+m+mf}{1.184226}           \PYG{l+m+mf}{51.654208}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08} \PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mo}{00}\PYG{p}{:}\PYG{l+m+mo}{00}                         \PYG{l+m+mf}{0.044550}          \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{14.860873}          \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{11.991508}                          \PYG{l+m+mf}{0.925637}           \PYG{l+m+mf}{40.476446}

                              \PYG{n}{u\PYGZus{}star} \PYG{n}{theta\PYGZus{}v\PYGZus{}star} \PYG{n}{theta\PYGZus{}star}            \PYG{n}{mrho\PYGZus{}h2o\PYGZus{}star}          \PYG{n}{Lo}            \PYG{n}{zeta}          \PYG{n}{q\PYGZus{}star}
                    \PYG{o}{\PYGZlt{}}\PYG{n}{meter} \PYG{o}{/} \PYG{n}{second}\PYG{o}{\PYGZgt{}}     \PYG{o}{\PYGZlt{}}\PYG{n}{kelvin}\PYG{o}{\PYGZgt{}}   \PYG{o}{\PYGZlt{}}\PYG{n}{kelvin}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{millimole} \PYG{o}{/} \PYG{n}{meter} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{3}\PYG{o}{\PYGZgt{}}     \PYG{o}{\PYGZlt{}}\PYG{n}{meter}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{dimensionless}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{dimensionless}\PYG{o}{\PYGZgt{}}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08} \PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mo}{00}\PYG{p}{:}\PYG{l+m+mo}{00}         \PYG{l+m+mf}{0.412886}     \PYG{l+m+mf}{0.156686}   \PYG{l+m+mf}{0.106865}                \PYG{l+m+mf}{16.971952}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{83.429641}       \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.032363}        \PYG{l+m+mf}{0.000266}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08} \PYG{l+m+mi}{12}\PYG{p}{:}\PYG{l+m+mo}{00}\PYG{p}{:}\PYG{l+m+mo}{00}         \PYG{l+m+mf}{0.247697}     \PYG{l+m+mf}{0.051834}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.025031}                \PYG{l+m+mf}{26.837060}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{90.992476}       \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.029673}        \PYG{l+m+mf}{0.000423}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08} \PYG{l+m+mi}{13}\PYG{p}{:}\PYG{l+m+mo}{00}\PYG{p}{:}\PYG{l+m+mo}{00}         \PYG{l+m+mf}{0.227652}     \PYG{l+m+mf}{0.048903}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.012763}                \PYG{l+m+mf}{21.417958}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{81.621514}       \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.033080}        \PYG{l+m+mf}{0.000338}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mo}{00}\PYG{p}{:}\PYG{l+m+mo}{00}         \PYG{l+m+mf}{0.122980}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.029651}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.099383}                \PYG{l+m+mf}{24.080946}   \PYG{l+m+mf}{39.583979}        \PYG{l+m+mf}{0.068209}        \PYG{l+m+mf}{0.000384}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08} \PYG{l+m+mi}{17}\PYG{p}{:}\PYG{l+m+mo}{00}\PYG{p}{:}\PYG{l+m+mo}{00}         \PYG{l+m+mf}{0.053951}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.041353}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.090986}                \PYG{l+m+mf}{17.260443}    \PYG{l+m+mf}{5.463569}        \PYG{l+m+mf}{0.494182}        \PYG{l+m+mf}{0.000276}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08} \PYG{l+m+mi}{18}\PYG{p}{:}\PYG{l+m+mo}{00}\PYG{p}{:}\PYG{l+m+mo}{00}         \PYG{l+m+mf}{0.153328}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.016003}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.038149}                 \PYG{l+m+mf}{7.723494}  \PYG{l+m+mf}{113.854892}        \PYG{l+m+mf}{0.023714}        \PYG{l+m+mf}{0.000123}
\PYG{l+m+mi}{2013}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08} \PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mo}{00}\PYG{p}{:}\PYG{l+m+mo}{00}         \PYG{l+m+mf}{0.198083}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.053132}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.065846}                 \PYG{l+m+mf}{4.672974}   \PYG{l+m+mf}{56.961515}        \PYG{l+m+mf}{0.047400}        \PYG{l+m+mf}{0.000074}
\end{Verbatim}

Note that the date parsing when reading the file comes is handy now, although
there are computationally faster ways to do it other than setting
\sphinxcode{parse\_dates=True} in the \sphinxcode{timeSeries()} call.


\section{Obtaining the spectra}
\label{tutorial:obtaining-the-spectra}
Using Numpy's fast Fourier transform implementation, Pymicra is also able to
extract spectra, co-spectra and quadratures.

We begin normally with out data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [17]: }\PYG{k+kn}{import} \PYG{n+nn}{pymicra} \PYG{k+kn}{as} \PYG{n+nn}{pm}

\PYG{g+gp}{In [18]: }\PYG{n}{fname} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../examples/ex\PYGZus{}data/20131108\PYGZhy{}1000.csv}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{g+gp}{In [19]: }\PYG{n}{fconfig} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{fileConfig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../examples/lake.config}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{g+gp}{In [20]: }\PYG{n}{data}\PYG{p}{,} \PYG{n}{units} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{timeSeries}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{,} \PYG{n}{fconfig}\PYG{p}{,} \PYG{n}{parse\PYGZus{}dates}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{g+gp}{In [21]: }\PYG{n}{data} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{rotateCoor}\PYG{p}{(}\PYG{n}{how}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{g+gp}{In [22]: }\PYG{n}{data} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{preProcess}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{units}\PYG{p}{,} \PYG{n}{expand\PYGZus{}temperature}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,}
\PYG{g+gp}{   ....: }    \PYG{n}{use\PYGZus{}means}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{n}{rho\PYGZus{}air\PYGZus{}from\PYGZus{}theta\PYGZus{}v}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{solutes}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{co2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{   ....: }
\PYG{g+go}{Beginning of pre\PYGZhy{}processing ...}
\PYG{g+go}{Converting theta\PYGZus{}v and theta to kelvin ... Done!}
\PYG{g+go}{Didn\PYGZsq{}t locate mass density of h2o. Trying to calculate it ... Done!}
\PYG{g+go}{Moist air density not present in dataset}
\PYG{g+go}{Calculating rho\PYGZus{}air = p/(Rdry * theta\PYGZus{}v) ... Done!}
\PYG{g+go}{Calculating dry\PYGZus{}air mass\PYGZus{}density = rho\PYGZus{}air \PYGZhy{} rho\PYGZus{}h2o ... Done!}
\PYG{g+go}{Dry air molar density not in dataset}
\PYG{g+go}{Calculating dry\PYGZus{}air molar\PYGZus{}density = rho\PYGZus{}dry / dry\PYGZus{}air\PYGZus{}molar\PYGZus{}mass ... Done!}
\PYG{g+go}{Calculating specific humidity = rho\PYGZus{}h2o / rho\PYGZus{}air ... Done!}
\PYG{g+go}{Calculating h2o mass mixing ratio = rho\PYGZus{}h2o / rho\PYGZus{}dry ... Done!}
\PYG{g+go}{Calculating h2o molar mixing ratio = rho\PYGZus{}h2o / rho\PYGZus{}dry ... Done!}
\PYG{g+go}{Didn\PYGZsq{}t locate mass density of co2. Trying to calculate it ... Done!}
\PYG{g+go}{Calculating co2 mass concentration (g/g) = rho\PYGZus{}co2 / rho\PYGZus{}air ... Done!}
\PYG{g+go}{Calculating co2 mass mixing ratio = rho\PYGZus{}co2 / rho\PYGZus{}dry ... Done!}
\PYG{g+go}{Calculating co2 molar mixing ratio = mrho\PYGZus{}co2 / mrho\PYGZus{}dry ... Done!}
\PYG{g+go}{Pre\PYGZhy{}processing complete.}


\PYG{g+gp}{In [23]: }\PYG{n}{ddata} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{detrend}\PYG{p}{(}\PYG{n}{how}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{linear}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{units}\PYG{o}{=}\PYG{n}{units}\PYG{p}{,} \PYG{n}{ignore}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{p}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{theta}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{g+gp}{In [24]: }\PYG{n}{spectra} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{spectra}\PYG{p}{(}\PYG{n}{ddata}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{q}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{theta\PYGZus{}v}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{frequency}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{anti\PYGZus{}aliasing}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{g+gp}{In [25]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{spectra}\PYG{p}{)}
\PYG{g+go}{                  sp\PYGZus{}q\PYGZsq{}  sp\PYGZus{}theta\PYGZus{}v\PYGZsq{}}
\PYG{g+go}{Frequency                           }
\PYG{g+go}{0.000000   1.577334e\PYGZhy{}12     0.000008}
\PYG{g+go}{0.000278   4.144727e\PYGZhy{}05    45.943783}
\PYG{g+go}{0.000556   3.865083e\PYGZhy{}05     3.334596}
\PYG{g+go}{0.000833   7.980502e\PYGZhy{}05    31.672784}
\PYG{g+go}{0.001111   1.073580e\PYGZhy{}05     2.803636}
\PYG{g+go}{0.001389   1.241483e\PYGZhy{}06     5.217900}
\PYG{g+go}{0.001667   3.835368e\PYGZhy{}06     1.047473}
\PYG{g+go}{0.001944   4.227195e\PYGZhy{}07     1.946339}
\PYG{g+go}{0.002222   2.814149e\PYGZhy{}05     2.102988}
\PYG{g+go}{0.002500   1.583606e\PYGZhy{}06     0.028766}
\PYG{g+go}{0.002778   2.811464e\PYGZhy{}05     3.580177}
\PYG{g+go}{0.003056   2.370466e\PYGZhy{}05     5.149250}
\PYG{g+go}{0.003333   2.293237e\PYGZhy{}05    10.265385}
\PYG{g+go}{0.003611   6.403187e\PYGZhy{}06     1.859855}
\PYG{g+go}{0.003889   9.423586e\PYGZhy{}06     2.375210}
\PYG{g+go}{...                 ...          ...}
\PYG{g+go}{9.996111   1.084777e\PYGZhy{}09     0.000124}
\PYG{g+go}{9.996389   1.158869e\PYGZhy{}08     0.000737}
\PYG{g+go}{9.996667   4.004893e\PYGZhy{}09     0.000586}
\PYG{g+go}{9.996944   1.888643e\PYGZhy{}09     0.000200}
\PYG{g+go}{9.997222   3.102855e\PYGZhy{}10     0.000402}
\PYG{g+go}{9.997500   3.321963e\PYGZhy{}10     0.000106}
\PYG{g+go}{9.997778   3.111850e\PYGZhy{}10     0.000146}
\PYG{g+go}{9.998056   2.923886e\PYGZhy{}10     0.000850}
\PYG{g+go}{9.998333   2.343816e\PYGZhy{}10     0.000508}
\PYG{g+go}{9.998611   7.671555e\PYGZhy{}10     0.000464}
\PYG{g+go}{9.998889   3.931099e\PYGZhy{}09     0.000459}
\PYG{g+go}{9.999167   9.530669e\PYGZhy{}10     0.000081}
\PYG{g+go}{9.999444   3.370132e\PYGZhy{}09     0.000122}
\PYG{g+go}{9.999722   2.259948e\PYGZhy{}10     0.000505}
\PYG{g+go}{10.000000  4.645530e\PYGZhy{}10     0.001140}

\PYG{g+go}{[36001 rows x 2 columns]}
\end{Verbatim}

We can plot it with the raw points, but it's hard to see anything

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [26]: }\PYG{n}{spectra}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{loglog}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{style}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gh}{Out[26]: }\PYG{g+go}{\PYGZlt{}matplotlib.axes.\PYGZus{}subplots.AxesSubplot at 0x7f7d8e748290\PYGZgt{}}

\PYG{g+gp}{In [27]: }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\noindent\sphinxincludegraphics{{spectra}.png}

The best option it to apply a binning procedure before plotting it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [28]: }\PYG{n}{spectra}\PYG{o}{.}\PYG{n}{binned}\PYG{p}{(}\PYG{n}{bins\PYGZus{}number}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{loglog}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{style}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gh}{Out[28]: }\PYG{g+go}{\PYGZlt{}matplotlib.axes.\PYGZus{}subplots.AxesSubplot at 0x7f7d8e31bad0\PYGZgt{}}

\PYG{g+gp}{In [29]: }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\noindent\sphinxincludegraphics{{spectra_binned}.png}

We can also calculate the cross-spectra

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [30]: }\PYG{n}{crspectra} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{crossSpectra}\PYG{p}{(}\PYG{n}{ddata}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{q}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{theta\PYGZus{}v}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{frequency}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{anti\PYGZus{}aliasing}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{g+gp}{In [31]: }\PYG{k}{print}\PYG{p}{(}\PYG{n}{crspectra}\PYG{p}{)}
\PYG{g+go}{                                     X\PYGZus{}q\PYGZsq{}\PYGZus{}theta\PYGZus{}v\PYGZsq{}                                  X\PYGZus{}q\PYGZsq{}\PYGZus{}w\PYGZsq{}                            X\PYGZus{}theta\PYGZus{}v\PYGZsq{}\PYGZus{}w\PYGZsq{}}
\PYG{g+go}{Frequency                                                                                                                           }
\PYG{g+go}{0.000000                    (3.64642595549e\PYGZhy{}09+0j)                   (4.42997418716e\PYGZhy{}10+0j)                   (1.02410628187e\PYGZhy{}06+0j)}
\PYG{g+go}{0.000278       (0.0431404707606\PYGZhy{}0.00656843186362j)    (\PYGZhy{}0.00601159315561+0.00764344401803j)          (\PYGZhy{}7.46848648027+7.00299465568j)}
\PYG{g+go}{0.000556       (0.00909424097384+0.0067955652924j)       (0.00662015331717\PYGZhy{}0.012703253092j)         (\PYGZhy{}0.675807329418\PYGZhy{}4.15292805414j)}
\PYG{g+go}{0.000833       (0.0496067630364+0.00817412807977j)   (\PYGZhy{}0.000691711708511+0.00755242279564j)          (0.343598570049+4.76543160858j)}
\PYG{g+go}{0.001111      (0.00484104482788+0.00258139013139j)        (\PYGZhy{}0.002261508595+0.002958157248j)         (\PYGZhy{}0.308491706877+1.87768027935j)}
\PYG{g+go}{0.001389    (\PYGZhy{}0.00252062835328+0.000352653072163j)    (0.00237400427977+0.000536610998917j)          (\PYGZhy{}4.66760091614\PYGZhy{}1.76385631957j)}
\PYG{g+go}{0.001667     (0.000581530584633\PYGZhy{}0.00191814143306j)     (0.00147491034621+0.00152581825106j)        (\PYGZhy{}0.539460590207+0.968980525892j)}
\PYG{g+go}{0.001944   (\PYGZhy{}0.000488827031498+0.000764070372007j)   (0.000136221918826+6.77467074179e\PYGZhy{}05j)        (\PYGZhy{}0.0350721992609\PYGZhy{}0.32456401482j)}
\PYG{g+go}{0.002222      (0.00687873261507+0.00344445084207j)      (0.0029147646648\PYGZhy{}0.00147566764488j)         (0.531848998543\PYGZhy{}0.717463373178j)}
\PYG{g+go}{0.002500   (\PYGZhy{}3.20032027175e\PYGZhy{}05+0.000211020463093j)    (0.000959520700828\PYGZhy{}0.00086587049931j)         (\PYGZhy{}0.134770968914\PYGZhy{}0.11036069695j)}
\PYG{g+go}{0.002778      (0.00914484576834+0.00412639808728j)     (0.00130655515532\PYGZhy{}0.00170561742482j)         (0.174648858167\PYGZhy{}0.746549794061j)}
\PYG{g+go}{0.003056       (0.00297280641473\PYGZhy{}0.0106406599447j)     (0.00220624778578+0.00567444669839j)          (\PYGZhy{}2.27048661708+1.70198460404j)}
\PYG{g+go}{0.003333       (0.0149860509294+0.00329056839565j)   (\PYGZhy{}0.00259518294404\PYGZhy{}0.000725287626379j)          (\PYGZhy{}1.7999953421\PYGZhy{}0.101584385679j)}
\PYG{g+go}{0.003611     (0.00339758185817+0.000604514115291j)   (\PYGZhy{}0.000827847258403+0.00297355512566j)         (\PYGZhy{}0.158533980555+1.65594753145j)}
\PYG{g+go}{0.003889     (0.00466685976134+0.000776798595543j)    (\PYGZhy{}0.00282762037168\PYGZhy{}0.00222452651306j)         (\PYGZhy{}1.58369821003\PYGZhy{}0.868571842093j)}
\PYG{g+go}{...                                            ...                                      ...                                      ...}
\PYG{g+go}{9.996111   (\PYGZhy{}3.00966155446e\PYGZhy{}07\PYGZhy{}2.09964207749e\PYGZhy{}07j)  (\PYGZhy{}7.46261459459e\PYGZhy{}07+1.34881230785e\PYGZhy{}06j)  (\PYGZhy{}5.40229561034e\PYGZhy{}05\PYGZhy{}0.000518664207694j)}
\PYG{g+go}{9.996389    (9.86724075233e\PYGZhy{}07\PYGZhy{}2.75125913256e\PYGZhy{}06j)     (\PYGZhy{}1.47663445849e\PYGZhy{}06\PYGZhy{}2.71710633e\PYGZhy{}07j)  (\PYGZhy{}6.12221317164e\PYGZhy{}05\PYGZhy{}0.000373701153871j)}
\PYG{g+go}{9.996667   (\PYGZhy{}1.20756421484e\PYGZhy{}06+9.41878022718e\PYGZhy{}07j)  (\PYGZhy{}1.60728034798e\PYGZhy{}06\PYGZhy{}1.61932245965e\PYGZhy{}07j)    (0.00044654723968+0.000426829311903j)}
\PYG{g+go}{9.996944   (\PYGZhy{}1.85202902306e\PYGZhy{}08\PYGZhy{}6.15032063274e\PYGZhy{}07j)   (1.28907886822e\PYGZhy{}06+2.79374256215e\PYGZhy{}07j)  (\PYGZhy{}0.000103618431941+0.000417045830281j)}
\PYG{g+go}{9.997222   (\PYGZhy{}3.02777208846e\PYGZhy{}07+1.81456590353e\PYGZhy{}07j)  (\PYGZhy{}4.11844312729e\PYGZhy{}07\PYGZhy{}4.47580373048e\PYGZhy{}08j)   (0.000375703825302+0.000284523744964j)}
\PYG{g+go}{9.997500    (1.86261188261e\PYGZhy{}07+2.21641762612e\PYGZhy{}08j)   (1.17248477329e\PYGZhy{}06\PYGZhy{}7.01784908781e\PYGZhy{}08j)   (0.000652725368031\PYGZhy{}0.000117577128686j)}
\PYG{g+go}{9.997778    (8.74534442357e\PYGZhy{}08\PYGZhy{}1.94132607794e\PYGZhy{}07j)    (3.5863011104e\PYGZhy{}07\PYGZhy{}1.03520888491e\PYGZhy{}06j)     (0.00074660164755\PYGZhy{}6.7197272793e\PYGZhy{}05j)}
\PYG{g+go}{9.998056    (4.80097791895e\PYGZhy{}07\PYGZhy{}1.34733818884e\PYGZhy{}07j)   (5.52736731063e\PYGZhy{}07\PYGZhy{}3.98018175528e\PYGZhy{}07j)    (0.00109099384549\PYGZhy{}0.000398836704681j)}
\PYG{g+go}{9.998333     (1.6826867691e\PYGZhy{}07+3.01393754479e\PYGZhy{}07j)  (\PYGZhy{}1.86557075023e\PYGZhy{}07+9.81927620647e\PYGZhy{}08j)  (\PYGZhy{}7.66709753361e\PYGZhy{}06+0.000310390782787j)}
\PYG{g+go}{9.998611   (\PYGZhy{}4.96402326019e\PYGZhy{}07\PYGZhy{}3.31429269153e\PYGZhy{}07j)  (\PYGZhy{}6.41016999642e\PYGZhy{}07\PYGZhy{}4.06693785042e\PYGZhy{}07j)   (0.000590483357437\PYGZhy{}1.37756359355e\PYGZhy{}05j)}
\PYG{g+go}{9.998889   (\PYGZhy{}7.93045719726e\PYGZhy{}07+1.08504506495e\PYGZhy{}06j)      (5.2007159701e\PYGZhy{}07+7.169547693e\PYGZhy{}07j)   (9.29734160856e\PYGZhy{}05\PYGZhy{}0.000288183813551j)}
\PYG{g+go}{9.999167    (2.70012075766e\PYGZhy{}07\PYGZhy{}6.29925739168e\PYGZhy{}08j)     (\PYGZhy{}1.2874391849e\PYGZhy{}06\PYGZhy{}4.174494327e\PYGZhy{}07j)  (\PYGZhy{}0.000337151474966\PYGZhy{}0.000203359800886j)}
\PYG{g+go}{9.999444   (\PYGZhy{}6.28929385556e\PYGZhy{}07+1.26376757642e\PYGZhy{}07j)  (\PYGZhy{}2.21335092292e\PYGZhy{}06+1.02519591583e\PYGZhy{}06j)    (0.00045149636163\PYGZhy{}0.000108322082259j)}
\PYG{g+go}{9.999722    (3.37062730718e\PYGZhy{}07\PYGZhy{}2.34723066532e\PYGZhy{}08j)  (\PYGZhy{}4.19929617984e\PYGZhy{}08+1.65355300419e\PYGZhy{}07j)  (\PYGZhy{}7.98050818792e\PYGZhy{}05+0.000242259733087j)}
\PYG{g+go}{10.000000                   (7.27769346786e\PYGZhy{}07+0j)                   (3.52033674659e\PYGZhy{}07+0j)                   (0.000551496430587+0j)}

\PYG{g+go}{[36001 rows x 3 columns]}
\end{Verbatim}

We can then get the cospectra and plot it's binned version (the same can be
done with the \sphinxcode{.quadrature()} method). It's important to note that, although
to pass from cross-spectra to cospectra one can merely do
\sphinxcode{data.apply(np.real)}, it's recommended to use the \sphinxcode{.cospectra()} method or
the \sphinxcode{pm.spectral.cospectra()} function, since this way the notation on the
resulting DataFrame will be correctly passed on, as you can see by the legend
in the resulting plot.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [32]: }\PYG{n}{cospectra} \PYG{o}{=} \PYG{n}{crspectra}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s2}{r\PYGZdq{}}\PYG{l+s+s2}{X\PYGZus{}q}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZus{}w}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{r\PYGZdq{}}\PYG{l+s+s2}{X\PYGZus{}theta\PYGZus{}v}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZus{}w}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{o}{.}\PYG{n}{cospectra}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{In [33]: }\PYG{n}{cospectra}\PYG{o}{.}\PYG{n}{binned}\PYG{p}{(}\PYG{n}{bins\PYGZus{}number}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{loglog}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{style}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gh}{Out[33]: }\PYG{g+go}{\PYGZlt{}matplotlib.axes.\PYGZus{}subplots.AxesSubplot at 0x7f7da6d36290\PYGZgt{}}

\PYG{g+gp}{In [34]: }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\noindent\sphinxincludegraphics{{cospectra_binned}.png}

Now we can finally obtain an Ogive with the \sphinxcode{pm.spectral.Ogive()} function.
Note that we plot \sphinxcode{Og/Og.sum()} (i.e. we normalize the ogive) instead of
\sphinxcode{Og} merely for visualization purposes, as the scale of both ogives are too
different.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{In [35]: }\PYG{n}{Og} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{spectral}\PYG{o}{.}\PYG{n}{Ogive}\PYG{p}{(}\PYG{n}{cospectra}\PYG{p}{)}

\PYG{g+gp}{In [36]: }\PYG{p}{(}\PYG{n}{Og}\PYG{o}{/}\PYG{n}{Og}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{logx}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+gh}{Out[36]: }\PYG{g+go}{\PYGZlt{}matplotlib.axes.\PYGZus{}subplots.AxesSubplot at 0x7f7d8e5bd1d0\PYGZgt{}}

\PYG{g+gp}{In [37]: }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\noindent\sphinxincludegraphics{{ogive}.png}

\begin{notice}{note}{Note:}
Include some examples for spectral corrections.
\end{notice}


\chapter{Pymicra's auto-generated docs}
\label{pymicra:pymicra-s-auto-generated-docs}\label{pymicra::doc}

\section{Subpackages}
\label{pymicra:subpackages}

\subsection{pymicra.algs package}
\label{pymicra.algs:pymicra-algs-package}\label{pymicra.algs::doc}

\subsubsection{Submodules}
\label{pymicra.algs:submodules}

\subsubsection{pymicra.algs.auxiliar}
\label{pymicra.algs:pymicra-algs-auxiliar}\label{pymicra.algs:module-pymicra.algs.auxiliar}\index{pymicra.algs.auxiliar (module)}\index{applyResult() (in module pymicra.algs.auxiliar)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.auxiliar.applyResult}\pysiglinewithargsret{\sphinxcode{pymicra.algs.auxiliar.}\sphinxbfcode{applyResult}}{\emph{result}, \emph{failed}, \emph{df}, \emph{control=None}, \emph{testname=None}, \emph{filename=None}, \emph{falseshow=False}, \emph{index\_n=None}}{}
Auxiliar function to be used with util.qcontrol
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{result}} (\emph{\texttt{bool}}) -- whether the test failed and succeeded

\item {} 
\textbf{\texttt{failed}} (\emph{\texttt{list}}) -- list of failed variables. None object if the test was successful

\item {} 
\textbf{\texttt{control}} (\emph{\texttt{dictionary}}) -- dictionary whose keys are the names of the tests and items are lists

\item {} 
\textbf{\texttt{testname}} (\emph{\texttt{string}}) -- name of the test (has to match control dict)

\item {} 
\textbf{\texttt{filename}} (\emph{\texttt{string}}) -- name or path or identifier of the file tested

\item {} 
\textbf{\texttt{falseshow}} (\emph{\texttt{bool}}) -- whether to show the failed variables or not

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{completeHM() (in module pymicra.algs.auxiliar)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.auxiliar.completeHM}\pysiglinewithargsret{\sphinxcode{pymicra.algs.auxiliar.}\sphinxbfcode{completeHM}}{\emph{string}}{}
Completes \%H\%M strings for cases when 2hours 0 minutes appear
as 020. Should be dropped eventually because this is pretty much a hack that
corrects for file configuration

\end{fulllineitems}

\index{first\_last() (in module pymicra.algs.auxiliar)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.auxiliar.first_last}\pysiglinewithargsret{\sphinxcode{pymicra.algs.auxiliar.}\sphinxbfcode{first\_last}}{\emph{fname}}{}
Returns first and last lines of a file

\end{fulllineitems}

\index{lenYear() (in module pymicra.algs.auxiliar)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.auxiliar.lenYear}\pysiglinewithargsret{\sphinxcode{pymicra.algs.auxiliar.}\sphinxbfcode{lenYear}}{\emph{year}}{}
Calculates the length of a year in days
Useful to figure out if a certain year is a leap year

\end{fulllineitems}

\index{stripDown() (in module pymicra.algs.auxiliar)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.auxiliar.stripDown}\pysiglinewithargsret{\sphinxcode{pymicra.algs.auxiliar.}\sphinxbfcode{stripDown}}{\emph{str, final='`, args={[}'\_', `-`{]}}}{}
Auxiliar function to strip down keywords from symbols

\end{fulllineitems}

\index{testValid() (in module pymicra.algs.auxiliar)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.auxiliar.testValid}\pysiglinewithargsret{\sphinxcode{pymicra.algs.auxiliar.}\sphinxbfcode{testValid}}{\emph{df\_valid}, \emph{testname='`}, \emph{falseverbose=True}, \emph{trueverbose=True}, \emph{filepath=None}}{}
Tests a boolean DataFrane obtained from the test and prints standard output
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{df\_valid}} (\emph{\texttt{pandas.Series}}) -- series contaning only True or False values for each of the variables, which should be the indexes

\item {} 
\textbf{\texttt{testname}} (\emph{\texttt{string}}) -- the name of the test that generated the True/False values

\item {} 
\textbf{\texttt{falseverbose}} (\emph{\texttt{bool}}) -- whether to return which variables caused a false result

\item {} 
\textbf{\texttt{trueverbose}} (\emph{\texttt{bool}}) -- whether to print something successful cases

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\textbf{result} (\emph{bool}) -- True if the run passed the passed

\item {} 
\textbf{failed} (\emph{list}) -- list of failed variables if result==False. None otherwise.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{pymicra.algs.general}
\label{pymicra.algs:pymicra-algs-general}\label{pymicra.algs:module-pymicra.algs.general}\index{pymicra.algs.general (module)}\index{classbin() (in module pymicra.algs.general)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.general.classbin}\pysiglinewithargsret{\sphinxcode{pymicra.algs.general.}\sphinxbfcode{classbin}}{\emph{x}, \emph{y}, \emph{bins\_number=100}, \emph{function=\textless{}function mean\textgreater{}}, \emph{xfunction=\textless{}function mean\textgreater{}}, \emph{logscale=True}}{}
Separates x and y inputs into bins based on the x array.
x and y do not have to be ordered.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{x}} (\emph{\texttt{np.array}}) -- independent variable

\item {} 
\textbf{\texttt{y}} (\emph{\texttt{np.array}}) -- dependent variable

\item {} 
\textbf{\texttt{bins\_number}} (\emph{\texttt{int}}) -- number of classes (or bins) desired

\item {} 
\textbf{\texttt{function}} (\emph{\texttt{callable}}) -- funtion to be applied to both x and y-bins in order to smooth the data

\item {} 
\textbf{\texttt{logscale}} (\emph{\texttt{boolean}}) -- whether or not to use a log-spaced scale to set the bins

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\emph{np.array} -- x binned

\item {} 
\emph{np.array} -- y binned

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{diff\_central() (in module pymicra.algs.general)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.general.diff_central}\pysiglinewithargsret{\sphinxcode{pymicra.algs.general.}\sphinxbfcode{diff\_central}}{\emph{x}, \emph{y}}{}
Applies the central finite difference scheme
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{x}} (\emph{\texttt{array}}) -- independent variable

\item {} 
\textbf{\texttt{y}} (\emph{\texttt{array}}) -- dependent variable

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{dydx} -- the dependent variable differentiated

\item[{Return type}] \leavevmode
array

\end{description}\end{quote}

\end{fulllineitems}

\index{file\_len() (in module pymicra.algs.general)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.general.file_len}\pysiglinewithargsret{\sphinxcode{pymicra.algs.general.}\sphinxbfcode{file\_len}}{\emph{fname}}{}
Returns length of a file through piping bash's function wc
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{fname}} (\emph{\texttt{string}}) -- path of the file

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_nearest() (in module pymicra.algs.general)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.general.find_nearest}\pysiglinewithargsret{\sphinxcode{pymicra.algs.general.}\sphinxbfcode{find\_nearest}}{\emph{array}, \emph{value}}{}
Smart and small function to find the index of the nearest value, in an array, of some other value
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{array}} (\emph{\texttt{array}}) -- list or array

\item {} 
\textbf{\texttt{value}} (\emph{\texttt{float}}) -- value to look for in the array

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{fitByDate() (in module pymicra.algs.general)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.general.fitByDate}\pysiglinewithargsret{\sphinxcode{pymicra.algs.general.}\sphinxbfcode{fitByDate}}{\emph{data}, \emph{degree=1}, \emph{rule=None}}{}
Given a pandas DataFrame with the index as datetime, this routine
fit a n-degree polynomial to the dataset
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pd.DataFrame, pd.Series}}) -- dataframe whose columns have to be fitted

\item {} 
\textbf{\texttt{degree}} (\emph{\texttt{int}}) -- degree of the polynomial. Default is 1.

\item {} 
\textbf{\texttt{rule}} (\emph{\texttt{str}}) -- pandas offside string. Ex.: ``10min''.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{fitWrap() (in module pymicra.algs.general)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.general.fitWrap}\pysiglinewithargsret{\sphinxcode{pymicra.algs.general.}\sphinxbfcode{fitWrap}}{\emph{x}, \emph{y}, \emph{degree=1}}{}
A wrapper to numpy.polyfit and numpy.polyval that fits data given an x and y arrays.
This is specifically designed to be used with by pandas.DataFrame.apply method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{x}} (\emph{\texttt{array, list}}) -- 

\item {} 
\textbf{\texttt{y}} (\emph{\texttt{array, list}}) -- 

\item {} 
\textbf{\texttt{degree}} (\emph{\texttt{int}}) -- 

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_index() (in module pymicra.algs.general)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.general.get_index}\pysiglinewithargsret{\sphinxcode{pymicra.algs.general.}\sphinxbfcode{get\_index}}{\emph{x}, \emph{to\_look\_for}}{}
Just like the .index method of lists, except it works for multiple values
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{x}} (\emph{\texttt{list or array}}) -- the main array

\item {} 
\textbf{\texttt{to\_look\_for}} (\emph{\texttt{list or array}}) -- the subset of the main whose indexes are desired

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{indexes} -- array with the indexes of each element in y

\item[{Return type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_notation() (in module pymicra.algs.general)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.general.get_notation}\pysiglinewithargsret{\sphinxcode{pymicra.algs.general.}\sphinxbfcode{get\_notation}}{\emph{notation\_def}}{}
Auxiliar function ro retrieve notation

\end{fulllineitems}

\index{inverse\_normal\_cdf() (in module pymicra.algs.general)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.general.inverse_normal_cdf}\pysiglinewithargsret{\sphinxcode{pymicra.algs.general.}\sphinxbfcode{inverse\_normal\_cdf}}{\emph{mu}, \emph{sigma}}{}
Applied the inverse normal cumulative distribution

mu: mean
sigma: standard deviation

\end{fulllineitems}

\index{latexify() (in module pymicra.algs.general)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.general.latexify}\pysiglinewithargsret{\sphinxcode{pymicra.algs.general.}\sphinxbfcode{latexify}}{\emph{variables}, \emph{math\_mode=True}}{}
\end{fulllineitems}

\index{limitedSubs() (in module pymicra.algs.general)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.general.limitedSubs}\pysiglinewithargsret{\sphinxcode{pymicra.algs.general.}\sphinxbfcode{limitedSubs}}{\emph{data}, \emph{max\_interp=3}, \emph{func=\textless{}function \textless{}lambda\textgreater{}\textgreater{}}}{}
Substitute elements for NaNs if a certain conditions given by fund is met at
a maximum of max\_interp times in a row.
If there are more than that number in a row, then they are not substituted.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.dataframe}}) -- data to be interpolated

\item {} 
\textbf{\texttt{max\_interp}} (\emph{\texttt{int}}) -- number of maximum NaNs in a row to interpolate

\item {} 
\textbf{\texttt{func}} (\emph{\texttt{function}}) -- function of x only that determines the which elements become NaNs. Should return
only True or False.

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{df} -- dataframe with the elements substituted

\item[{Return type}] \leavevmode
pandas.dataframe

\end{description}\end{quote}

\end{fulllineitems}

\index{limited\_interpolation() (in module pymicra.algs.general)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.general.limited_interpolation}\pysiglinewithargsret{\sphinxcode{pymicra.algs.general.}\sphinxbfcode{limited\_interpolation}}{\emph{data}, \emph{maxcount=3}}{}
Interpolates linearly but only if gap is smaller of equal to maxcout
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame}}) -- dataset to interpolate

\item {} 
\textbf{\texttt{maxcount}} (\emph{\texttt{int}}) -- maximum number of consecutive NaNs to interpolate. If the number is smaller than that, nothing is done with the points.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{line2date() (in module pymicra.algs.general)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.general.line2date}\pysiglinewithargsret{\sphinxcode{pymicra.algs.general.}\sphinxbfcode{line2date}}{\emph{line}, \emph{dlconfig}}{}
Gets a date from a line of file according to dataloggerConfig object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{line}} (\emph{\texttt{string}}) -- line of file with date inside

\item {} 
\textbf{\texttt{dlconfig}} (\emph{\texttt{pymicra.dataloggerConfig}}) -- configuration of the datalogger

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{timestamp}

\item[{Return type}] \leavevmode
datetime object

\end{description}\end{quote}

\end{fulllineitems}

\index{mad() (in module pymicra.algs.general)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.general.mad}\pysiglinewithargsret{\sphinxcode{pymicra.algs.general.}\sphinxbfcode{mad}}{\emph{data}, \emph{axis=None}}{}
\end{fulllineitems}

\index{name2date() (in module pymicra.algs.general)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.general.name2date}\pysiglinewithargsret{\sphinxcode{pymicra.algs.general.}\sphinxbfcode{name2date}}{\emph{filename}, \emph{dlconfig}}{}
Gets a date from a the name of the file according to a datalogger config object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filename}} (\emph{\texttt{string}}) -- the (base) name of the file

\item {} 
\textbf{\texttt{dlconfig}} (\emph{\texttt{pymicra.dataloggerConfig}}) -- configuration of the datalogger

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\textbf{cdate} (\emph{datetime object})

\item {} 
\emph{Warning: Needs to be optimized in order to read question markers also after the date}

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{parseDates() (in module pymicra.algs.general)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.general.parseDates}\pysiglinewithargsret{\sphinxcode{pymicra.algs.general.}\sphinxbfcode{parseDates}}{\emph{data}, \emph{dataloggerConfig=None}, \emph{date\_col\_names=None}, \emph{clean=True}, \emph{verbose=False}, \emph{connector='`}}{}
Author: Tomas Chor
date: 2015-08-10
This routine parses the date from a pandas DataFrame when it is divided into several columns
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas DataFrame}}) -- dataFrame whose dates have to be parsed

\item {} 
\textbf{\texttt{date\_col\_names}} (\emph{\texttt{list}}) -- A list of the names of the columns in which the date is divided
the naming of the date columns must be in accordance with the datetime directives,
so if the first column is only the year, its name must be \sphinxtitleref{\%Y} and so forth.
see \url{https://docs.python.org/2/library/datetime.html\#strftime-and-strptime-behavior}

\item {} 
\textbf{\texttt{connector}} (\emph{\texttt{string}}) -- should be used only when the default connector causes some conflit

\item {} 
\textbf{\texttt{first\_time\_skip}} (\emph{\texttt{int}}) -- the offset (mostly because of the bad converting done by LBA

\item {} 
\textbf{\texttt{clean}} (\emph{\texttt{bool}}) -- remove date columns from data after it is introduced as index

\end{itemize}

\item[{Returns}] \leavevmode
data indexed by timestamp

\item[{Return type}] \leavevmode
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{resample() (in module pymicra.algs.general)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.general.resample}\pysiglinewithargsret{\sphinxcode{pymicra.algs.general.}\sphinxbfcode{resample}}{\emph{df}, \emph{rule}, \emph{how=None}, \emph{**kwargs}}{}
Extends pandas resample methods to index made of integers

\end{fulllineitems}

\index{splitData() (in module pymicra.algs.general)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.general.splitData}\pysiglinewithargsret{\sphinxcode{pymicra.algs.general.}\sphinxbfcode{splitData}}{\emph{data}, \emph{rule=`30min'}, \emph{return\_index=False}, \emph{**kwargs}}{}
Splits a given pandas DataFrame into a series of ``rule''-spaced DataFrames
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas dataframe}}) -- data to be split

\item {} 
\textbf{\texttt{rule}} (\emph{\texttt{str or int}}) -- \begin{description}
\item[{If it is a string, it should be a pandas string offset.}] \leavevmode
Some possible values (that should be followed by an integer) are:
D   calendar day frequency
W   weekly frequency
M   month end frequency
MS  month start frequency
Q   quarter end frequency
BQ  business quarter endfrequency
QS  quarter start frequency
A   year end frequency
AS  year start frequency
H   hourly frequency
T   minutely frequency
Min minutely frequency
S   secondly frequency
L   milliseconds
U   microseconds

\end{description}

If it is a int, it should be the number of lines desired in each separated piece.

If it is None, then the dataframe isn't separated and a list containing only the
full dataframe is returned.

check it complete at \url{http://pandas.pydata.org/pandas-docs/stable/timeseries.html\#offset-aliases}


\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{pymicra.algs.numeric}
\label{pymicra.algs:module-pymicra.algs.numeric}\label{pymicra.algs:pymicra-algs-numeric}\index{pymicra.algs.numeric (module)}

\subsubsection{pymicra.algs.units}
\label{pymicra.algs:pymicra-algs-units}\label{pymicra.algs:module-pymicra.algs.units}\index{pymicra.algs.units (module)}\index{add() (in module pymicra.algs.units)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.units.add}\pysiglinewithargsret{\sphinxcode{pymicra.algs.units.}\sphinxbfcode{add}}{\emph{elems}, \emph{units}, \emph{inplace\_units=False}, \emph{unitdict=None}, \emph{key=None}}{}
Add elements considering their units

\end{fulllineitems}

\index{convert\_cols() (in module pymicra.algs.units)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.units.convert_cols}\pysiglinewithargsret{\sphinxcode{pymicra.algs.units.}\sphinxbfcode{convert\_cols}}{\emph{data}, \emph{guide}, \emph{units}, \emph{inplace\_units=False}}{}
Converts data from one unit to the other
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame}}) -- to be chanhed from one unit to the other

\item {} 
\textbf{\texttt{guide}} (\emph{\texttt{dict}}) -- \{names of columns : units to converted to\}

\item {} 
\textbf{\texttt{units}} (\emph{\texttt{dict}}) -- units dictionary

\item {} 
\textbf{\texttt{inplace\_units}} (\emph{\texttt{bool}}) -- if inunit is a dict, the dict is update in place. ``key'' keyword must be provided

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{convert\_indexes() (in module pymicra.algs.units)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.units.convert_indexes}\pysiglinewithargsret{\sphinxcode{pymicra.algs.units.}\sphinxbfcode{convert\_indexes}}{\emph{data}, \emph{guide}, \emph{units}, \emph{inplace\_units=False}}{}
Converts data from one unit to the other
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.Series}}) -- to be chanhed from one unit to the other

\item {} 
\textbf{\texttt{guide}} (\emph{\texttt{dict}}) -- \{names of columns : units to converted to\}

\item {} 
\textbf{\texttt{units}} (\emph{\texttt{dict}}) -- units dictionary

\item {} 
\textbf{\texttt{inplace\_units}} (\emph{\texttt{bool}}) -- if inunit is a dict, the dict is update in place. ``key'' keyword must be provided

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{convert\_to() (in module pymicra.algs.units)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.units.convert_to}\pysiglinewithargsret{\sphinxcode{pymicra.algs.units.}\sphinxbfcode{convert\_to}}{\emph{data}, \emph{inunit}, \emph{outunit}, \emph{inplace\_units=False}, \emph{key=None}}{}
Converts data from one unit to the other
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.series}}) -- to be chanhed from one unit to the other

\item {} 
\textbf{\texttt{inunit}} (\emph{\texttt{pint.quantity or dict}}) -- unit(s) that the data is in

\item {} 
\textbf{\texttt{outunit}} (\emph{\texttt{str}}) -- convert to this unit

\item {} 
\textbf{\texttt{inplace\_units}} (\emph{\texttt{bool}}) -- if inunit is a dict, the dict is update in place. ``key'' keyword must be provided

\item {} 
\textbf{\texttt{key}} (\emph{\texttt{str}}) -- if inunit is a dict, it is the name of the variable to be changed

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{divide() (in module pymicra.algs.units)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.units.divide}\pysiglinewithargsret{\sphinxcode{pymicra.algs.units.}\sphinxbfcode{divide}}{\emph{elems}, \emph{units}, \emph{inplace\_units=False}, \emph{unitdict=None}, \emph{key=None}}{}
Divide elements considering their units

\end{fulllineitems}

\index{multiply() (in module pymicra.algs.units)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.units.multiply}\pysiglinewithargsret{\sphinxcode{pymicra.algs.units.}\sphinxbfcode{multiply}}{\emph{elems}, \emph{units}, \emph{inplace\_units=False}, \emph{unitdict=None}, \emph{key=None}}{}
Multiply elements considering their units

\end{fulllineitems}

\index{operate() (in module pymicra.algs.units)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.units.operate}\pysiglinewithargsret{\sphinxcode{pymicra.algs.units.}\sphinxbfcode{operate}}{\emph{elems}, \emph{units}, \emph{inplace\_units=False}, \emph{unitdict=None}, \emph{key=None}, \emph{operation='+'}}{}
Operate on elements considering their units
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{elems}} (\emph{\texttt{list, tuple}}) -- list of pandas.Series

\item {} 
\textbf{\texttt{units}} (\emph{\texttt{list, tuple}}) -- list of pint.units ordered as the elems list

\item {} 
\textbf{\texttt{inplace\_units}} (\emph{\texttt{bool}}) -- sets dictionary inplace\_units

\item {} 
\textbf{\texttt{unitdict}} (\emph{\texttt{dict}}) -- dict to be set inplace

\item {} 
\textbf{\texttt{key}} (\emph{\texttt{str}}) -- name of variables to be set inplace as dict key

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{parseUnits() (in module pymicra.algs.units)}

\begin{fulllineitems}
\phantomsection\label{pymicra.algs:pymicra.algs.units.parseUnits}\pysiglinewithargsret{\sphinxcode{pymicra.algs.units.}\sphinxbfcode{parseUnits}}{\emph{unitstr}}{}
Gets unit from string, list of strings, or dict's values, using the UnitRegistry
defined in \_\_init\_\_.py

\end{fulllineitems}



\subsubsection{Module contents}
\label{pymicra.algs:module-pymicra.algs}\label{pymicra.algs:module-contents}\index{pymicra.algs (module)}

\subsection{pymicra.micro package}
\label{pymicra.micro:pymicra-micro-package}\label{pymicra.micro::doc}

\subsubsection{Submodules}
\label{pymicra.micro:submodules}

\subsubsection{pymicra.micro.functions}
\label{pymicra.micro:module-pymicra.micro.functions}\label{pymicra.micro:pymicra-micro-functions}\index{pymicra.micro.functions (module)}\index{Psi() (in module pymicra.micro.functions)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.functions.Psi}\pysiglinewithargsret{\sphinxcode{pymicra.micro.functions.}\sphinxbfcode{Psi}}{\emph{zeta}, \emph{x='tau'}, \emph{zeta0=0.0}}{}
Integral Monin-Obukhov scale or deviation function, which is the deviation of a
variable (x) in relation nto their logarithmic profiles due the stability zeta != 0

Taken from Simpson.ea1998--the.validity.of.similarity.theory;.in.the.roughness.sublayer
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{zeta}} (\emph{\texttt{float}}) -- the stability variable

\item {} 
\textbf{\texttt{x}} (\emph{\texttt{string}}) -- the variable. Options are `tau', `H', `E', `F'

\item {} 
\textbf{\texttt{zeta0}} (\emph{\texttt{float}}) -- value of zeta\_\{0 x\}. Only used for the stable case

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{nondimensionalGrad() (in module pymicra.micro.functions)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.functions.nondimensionalGrad}\pysiglinewithargsret{\sphinxcode{pymicra.micro.functions.}\sphinxbfcode{nondimensionalGrad}}{\emph{zeta}, \emph{x=None}}{}
The nondimensional gradients, defined as:

phi\_F(zeta) = kappa*(z-d)*dCdz/c\_star
phi\_H(zeta) = kappa*(z-d)*dTdz/T\_star
phi\_E(zeta) = kappa*(z-d)*dqdz/q\_star

Currently using Businger-Dyer eqs.

TODO: generalize coefficients

\end{fulllineitems}

\index{nondimensionalSTD() (in module pymicra.micro.functions)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.functions.nondimensionalSTD}\pysiglinewithargsret{\sphinxcode{pymicra.micro.functions.}\sphinxbfcode{nondimensionalSTD}}{\emph{zeta}, \emph{x=None}}{}
The nondimensional standard deviation function, defined as:

phi\_c(zeta) = sigma\_c / c\_star

From zahn.ea

\end{fulllineitems}

\index{rte() (in module pymicra.micro.functions)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.functions.rte}\pysiglinewithargsret{\sphinxcode{pymicra.micro.functions.}\sphinxbfcode{rte}}{\emph{data}, \emph{w\_fluctuations=''w'''}, \emph{order=None}}{}
Returns the Relative Transfer Efficiency in the time domain, rte
according to Cancelli, Dias, Chamecki. Dimensionless criteria for the production-dissipation equilibrium
of scalar fluctuations and their implications for scalar similarity, Water Resources Research, 2012
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{order}} (\emph{\texttt{2-elements list}}) -- order of variables: if its rte\_ab should be {[}a,b{]}, if its rte\_ba should {[}b,a{]}

\item {} 
\textbf{\texttt{TO BE VALIDATED!}} (\emph{\texttt{NEEDS}}) -- 

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{ste() (in module pymicra.micro.functions)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.functions.ste}\pysiglinewithargsret{\sphinxcode{pymicra.micro.functions.}\sphinxbfcode{ste}}{\emph{data}, \emph{w\_fluctuations=''w'''}}{}
Returns the Symmetric Transfer Efficiency in the time domain, ste
according to Cancelli, Dias, Chamecki. Dimensionless criteria for the production-dissipation equilibrium
of scalar fluctuations and their implications for scalar similarity, Water Resources Research, 2012
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas dataframe}}) -- a three-columns dataframe, where one of them should be the vertical velocity fluctuations

\item {} 
\textbf{\texttt{w\_fluctuations}} (\emph{\texttt{str}}) -- the name of the vertical velocity fluctuations

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{pymicra.micro.scales}
\label{pymicra.micro:module-pymicra.micro.scales}\label{pymicra.micro:pymicra-micro-scales}\index{pymicra.micro.scales (module)}\index{MonObuLen() (in module pymicra.micro.scales)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.scales.MonObuLen}\pysiglinewithargsret{\sphinxcode{pymicra.micro.scales.}\sphinxbfcode{MonObuLen}}{\emph{theta\_v\_star}, \emph{theta\_v\_mean}, \emph{u\_star}, \emph{g=None}}{}
Redirects to obukhovLen()

\end{fulllineitems}

\index{MonObuVar() (in module pymicra.micro.scales)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.scales.MonObuVar}\pysiglinewithargsret{\sphinxcode{pymicra.micro.scales.}\sphinxbfcode{MonObuVar}}{\emph{L\_m}, \emph{siteConf}}{}
Redirects to stabilityParam()

\end{fulllineitems}

\index{obukhovLen() (in module pymicra.micro.scales)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.scales.obukhovLen}\pysiglinewithargsret{\sphinxcode{pymicra.micro.scales.}\sphinxbfcode{obukhovLen}}{\emph{data}, \emph{units}, \emph{theta\_v\_mean=None}, \emph{theta\_v\_mean\_unit=None}, \emph{notation=None}, \emph{inplace\_units=True}}{}
Calculates the Monin-Obukhov Length
according to:

GARRAT, The atmospheric boundary layer, 1992 (eq. 1.11, p. 10)
L = ( u\_star\textasciicircum{}2 * theta\_v ) / ( kappa * g * theta\_v\_star )

KUNDU, Fluid mechanics, 1990 (eq 71, chap. 12, p. 462)
L\_M = - u\_star\textasciicircum{}3 / ( kappa * alpha * g * cov(w,T') )

ARYA, Introduction to micrometeorology (eq. 11.1, p. 214)
L = - u\_star\textasciicircum{}3 / (kappa * (g/T\_0) * (H\_0/(rho*c\_p)) )

STULL, An introduction to Boundary layer meteorology, 1988 (eq. 5.7b, p. 181)
L = - ( theta\_v * u\_star\textasciicircum{}3 ) / ( kappa \emph{g} cov(w',theta\_v') )

\end{fulllineitems}

\index{stabilityParam() (in module pymicra.micro.scales)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.scales.stabilityParam}\pysiglinewithargsret{\sphinxcode{pymicra.micro.scales.}\sphinxbfcode{stabilityParam}}{\emph{L\_m}, \emph{siteConf}}{}
Calculates the Monin-Obukhov Similarity Variable
defined as

zeta = (z-d)/Lo
where d is the displacement height or zero-plane displacement
and L\_m is the Monin-Obukhov Length.

\end{fulllineitems}

\index{turbulentScales() (in module pymicra.micro.scales)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.scales.turbulentScales}\pysiglinewithargsret{\sphinxcode{pymicra.micro.scales.}\sphinxbfcode{turbulentScales}}{\emph{data}, \emph{siteConf}, \emph{units}, \emph{notation=None}, \emph{theta\_v\_mean=None}, \emph{theta\_v\_mean\_unit=None}, \emph{theta\_fluct\_from\_theta\_v=True}, \emph{solutes={[}{]}}, \emph{output\_as\_df=True}, \emph{inplace\_units=True}}{}
Calculates characteristic lengths for data

The names of the variables are retrived out the dictionary. You can update the dictionary
and change the names by using the notation\_defs keyworkd, which is a notation object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame}}) -- dataset to be used. It must either be the raw and turbulent data, or the covariances of such data

\item {} 
\textbf{\texttt{siteConf}} (\emph{\texttt{pymicra.siteConfig object}}) -- has the site configurations to calculate the obukhovLen

\item {} 
\textbf{\texttt{units}} (\emph{\texttt{dict}}) -- dict units for the input data

\item {} 
\textbf{\texttt{output\_as\_df}} (\emph{\texttt{boolean}}) -- True if you want the output to be a one-line pandas.DataFrame. A pd.Series
will be output if False.

\item {} 
\textbf{\texttt{inplace\_units}} (\emph{\texttt{bool}}) -- whether or not to update the units dict in place

\end{itemize}

\item[{Returns}] \leavevmode
depending on return\_as\_df

\item[{Return type}] \leavevmode
pandas.Series or pandas.Dataframe

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{pymicra.micro.spectral}
\label{pymicra.micro:pymicra-micro-spectral}\label{pymicra.micro:module-pymicra.micro.spectral}\index{pymicra.micro.spectral (module)}\index{Ogive() (in module pymicra.micro.spectral)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.spectral.Ogive}\pysiglinewithargsret{\sphinxcode{pymicra.micro.spectral.}\sphinxbfcode{Ogive}}{\emph{df}, \emph{no\_nan=True}}{}
Integrates the Ogive from Coespectra
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{df}} (\emph{\texttt{dataframe}}) -- cospectrum to be integrated

\end{description}\end{quote}

\end{fulllineitems}

\index{correctLag() (in module pymicra.micro.spectral)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.spectral.correctLag}\pysiglinewithargsret{\sphinxcode{pymicra.micro.spectral.}\sphinxbfcode{correctLag}}{\emph{*args}, \emph{**kwargs}}{}
Identifies and correct lags between data, assuming the
vertical wind velocity has lag 0.

\end{fulllineitems}

\index{cospectra() (in module pymicra.micro.spectral)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.spectral.cospectra}\pysiglinewithargsret{\sphinxcode{pymicra.micro.spectral.}\sphinxbfcode{cospectra}}{\emph{*args}, \emph{**kwargs}}{}
Gets cospectra from cross-spectrum

\end{fulllineitems}

\index{hfc\_Dias\_ea\_16() (in module pymicra.micro.spectral)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.spectral.hfc_Dias_ea_16}\pysiglinewithargsret{\sphinxcode{pymicra.micro.spectral.}\sphinxbfcode{hfc\_Dias\_ea\_16}}{\emph{cross\_spec}, \emph{T}}{}
Applies correction to high frequencies using the quadrature.
Xab\_ab = Co\_ab - i Qu\_ab

Co\_recovered = Co\_ab + 2*pi*n*T*Qu\_ab
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{cross\_spec}} (\emph{\texttt{series of dataframe}}) -- the cross spectrum whose coespectrum you'd like to correct

\item {} 
\textbf{\texttt{T}} (\emph{\texttt{float}}) -- response time to use

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{hfc\_Massman\_Ibrom\_08() (in module pymicra.micro.spectral)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.spectral.hfc_Massman_Ibrom_08}\pysiglinewithargsret{\sphinxcode{pymicra.micro.spectral.}\sphinxbfcode{hfc\_Massman\_Ibrom\_08}}{\emph{df}}{}
\end{fulllineitems}

\index{hfc\_zeroQuad() (in module pymicra.micro.spectral)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.spectral.hfc_zeroQuad}\pysiglinewithargsret{\sphinxcode{pymicra.micro.spectral.}\sphinxbfcode{hfc\_zeroQuad}}{\emph{slow\_spec}, \emph{freqs}, \emph{T}}{}
Applies a correction factor to the spectrum of a slow-measured variable
based on the response-time T. Quadrature must be analytically zero!
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{slow\_spec}} (\emph{\texttt{numpy.array or series}}) -- the spectrum to be corrected (not cross-spectrum!)

\item {} 
\textbf{\texttt{freqs}} (\emph{\texttt{numpy.array}}) -- frequencies

\item {} 
\textbf{\texttt{T}} (\emph{\texttt{float}}) -- the response-time

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{spec} -- the recovered array

\item[{Return type}] \leavevmode
numpy.array

\end{description}\end{quote}

\end{fulllineitems}

\index{phaseCorrection() (in module pymicra.micro.spectral)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.spectral.phaseCorrection}\pysiglinewithargsret{\sphinxcode{pymicra.micro.spectral.}\sphinxbfcode{phaseCorrection}}{\emph{cross\_spec}, \emph{T}}{}
\end{fulllineitems}

\index{quadrature() (in module pymicra.micro.spectral)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.spectral.quadrature}\pysiglinewithargsret{\sphinxcode{pymicra.micro.spectral.}\sphinxbfcode{quadrature}}{\emph{*args}, \emph{**kwargs}}{}
Gets quadrature from cross-spectrum

\end{fulllineitems}

\index{recspeAux() (in module pymicra.micro.spectral)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.spectral.recspeAux}\pysiglinewithargsret{\sphinxcode{pymicra.micro.spectral.}\sphinxbfcode{recspeAux}}{\emph{df}, \emph{T}}{}
Wrapper to make hfc\_zeroQuad work in a pandas.DataFrame

\end{fulllineitems}

\index{zeroQuadCorrection() (in module pymicra.micro.spectral)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.spectral.zeroQuadCorrection}\pysiglinewithargsret{\sphinxcode{pymicra.micro.spectral.}\sphinxbfcode{zeroQuadCorrection}}{\emph{*args}, \emph{**kwargs}}{}
Applies the correction assuming that the quadrature is zero to
a dataframe with spectra

Wrapper to make hfc\_zeroQuad work in a pandas.DataFrame
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{df}} (\emph{\texttt{pandas.DataFrame}}) -- dataframe with cospectra to correct

\item {} 
\textbf{\texttt{T}} (\emph{\texttt{float}}) -- response time to be used

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{pymicra.micro.util}
\label{pymicra.micro:pymicra-micro-util}\label{pymicra.micro:module-pymicra.micro.util}\index{pymicra.micro.util (module)}\index{eddyCovariance() (in module pymicra.micro.util)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.util.eddyCovariance}\pysiglinewithargsret{\sphinxcode{pymicra.micro.util.}\sphinxbfcode{eddyCovariance}}{\emph{data}, \emph{units}, \emph{wpl=True}, \emph{get\_turbulent\_scales=True}, \emph{site\_config=None}, \emph{output\_as\_df=True}, \emph{notation=None}, \emph{theta\_fluct\_from\_theta\_v=True}, \emph{inplace\_units=True}, \emph{solutes={[}{]}}}{}
Get fluxes from the turbulent fluctuations
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame}}) -- dataframe with the characteristic lengths calculated

\item {} 
\textbf{\texttt{units}} (\emph{\texttt{dict}}) -- units dictionary

\item {} 
\textbf{\texttt{wpl}} (\emph{\texttt{boolean}}) -- whether or not to apply WPL correction on the latent heat flux and solutes flux

\item {} 
\textbf{\texttt{get\_turbulent\_scales}} (\emph{\texttt{bool}}) -- whether or not to use getScales to return turbulent scales

\item {} 
\textbf{\texttt{site\_config}} (\emph{\texttt{pymica.siteConfig}}) -- siteConfig object to pass to getScales if get\_turbulent\_scales==True

\item {} 
\textbf{\texttt{notation}} (\emph{\texttt{pymicra.Notation}}) -- object that holds the notation used in the dataframe

\item {} 
\textbf{\texttt{inplace\_units}} (\emph{\texttt{bool}}) -- whether or not to treat the units inplace

\item {} 
\textbf{\texttt{solutes}} (\emph{\texttt{list}}) -- list that holds every solute considered for flux

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{preProcess() (in module pymicra.micro.util)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.util.preProcess}\pysiglinewithargsret{\sphinxcode{pymicra.micro.util.}\sphinxbfcode{preProcess}}{\emph{data}, \emph{units}, \emph{notation=None}, \emph{use\_means=False}, \emph{expand\_temperature=True}, \emph{rho\_air\_from\_theta\_v=True}, \emph{inplace\_units=True}, \emph{theta=None}, \emph{theta\_unit=None}, \emph{solutes={[}{]}}}{}
Calculates moist and dry air densities, specific humidity mass density and other
important variables using the variables provided in the input DataFrame.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame}}) -- dataframe with micrometeorological measurements

\item {} 
\textbf{\texttt{units}} (\emph{\texttt{dict}}) -- units dictionary with the columns of data as keys

\item {} 
\textbf{\texttt{notation}} (\emph{\texttt{pymicra.notation}}) -- defining notation used in data

\item {} 
\textbf{\texttt{rho\_air\_from\_theta\_v}} (\emph{\texttt{bool}}) -- whether to use theta\_v to calculate air density or theta

\item {} 
\textbf{\texttt{inplace\_units}} (\emph{\texttt{bool}}) -- treat units inplace or not

\item {} 
\textbf{\texttt{theta}} (\emph{\texttt{pandas.Series}}) -- auxiliar theta measurement to be used if rho\_air\_from\_theta\_v==False

\item {} 
\textbf{\texttt{theta\_unit}} (\emph{\texttt{pint.quantity}}) -- auxiliar theta measurement's unit to be used if rho\_air\_from\_theta\_v==False

\item {} 
\textbf{\texttt{solutes}} (\emph{\texttt{list}}) -- list of string where each string is a solute to be considered

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{data} -- dataframe with original columns and new calculated ones

\item[{Return type}] \leavevmode
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{rotateCoor() (in module pymicra.micro.util)}

\begin{fulllineitems}
\phantomsection\label{pymicra.micro:pymicra.micro.util.rotateCoor}\pysiglinewithargsret{\sphinxcode{pymicra.micro.util.}\sphinxbfcode{rotateCoor}}{\emph{data}, \emph{notation=None}, \emph{how=`2d'}}{}
\end{fulllineitems}



\subsubsection{Module contents}
\label{pymicra.micro:module-contents}\label{pymicra.micro:module-pymicra.micro}\index{pymicra.micro (module)}
Submodule that holds the specifically micrometeorological functions and variables


\section{pymicra.constants}
\label{pymicra:module-pymicra.constants}\label{pymicra:pymicra-constants}\index{pymicra.constants (module)}
Defines some useful constants


\section{pymicra.core}
\label{pymicra:module-pymicra.core}\label{pymicra:pymicra-core}\index{pymicra.core (module)}
Defines classes that are the basis of Pymicra
\index{Notation (class in pymicra.core)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{pymicra.core.}\sphinxbfcode{Notation}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{object}

Holds the notation used in every function of pymicra except when told otherwise.
\index{build() (pymicra.core.Notation method)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.build}\pysiglinewithargsret{\sphinxbfcode{build}}{\emph{from\_level=0}}{}
This useful method builds the full notation based on the base notation.

Given notation for means, fluctuations, and etc, along with names of variables, this
method builds the notation for mean h2o concentration, virtual temperature fluctuations
and so on.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{self}} (\emph{\texttt{pymicra.Notation}}) -- notation to be built

\item {} 
\textbf{\texttt{from\_level}} (\emph{\texttt{int}}) -- level from which to build. If 0, build everything from scratch and higher notations
will be overwritten. If 1, skip one step in building process. Still to be implemented!

\end{itemize}

\item[{Returns}] \leavevmode
Notation object with built notation

\item[{Return type}] \leavevmode
pymicra.Notation

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{fileConfig (class in pymicra.core)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.fileConfig}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{pymicra.core.}\sphinxbfcode{fileConfig}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{object}

This class defines a specific configuration of a data file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{from\_file}} (\emph{\texttt{str}}) -- path of .cfg file (configuration file) to read from. This will ignore all other
keywords.

\item {} 
\textbf{\texttt{variables}} (\emph{\texttt{list of strings or dict}}) -- If a list: should be a list of strings with the names of the variables. If the variable
is part if the date, then it should be provided as a datetime directive,
so if the columns is only the year, its name must be \sphinxtitleref{\%Y} and so forth. While
if it is the date in YYYY/MM/DD format, it should be \sphinxtitleref{\%Y/\%m/\%d}. For more info
see \url{https://docs.python.org/2/library/datetime.html\#strftime-and-strptime-behavior}
If a dict: the keys should be the numbers of the columns and the items should follow
the rules for a list.

\item {} 
\textbf{\texttt{date\_cols}} (\emph{\texttt{list of ints}}) -- should be indexes of the subset of varNames that corresponds to the variables that compose
the timestamp. If it is not provided the program will try to guess by getting
all variable names that have a percentage sign (\%).

\item {} 
\textbf{\texttt{date\_connector}} (\emph{\texttt{string}}) -- generally not really necessary. It is used to join and then parse the date\_cols.

\item {} 
\textbf{\texttt{columns\_separator}} (\emph{\texttt{string}}) -- used to assemble the date. If the file is tabular-separated then this should be ``whitespace''.

\item {} 
\textbf{\texttt{header\_lines}} (\emph{\texttt{int or list}}) -- up to which line of the file is a header. See pandas.read\_csv header option.

\item {} 
\textbf{\texttt{filename\_format}} (\emph{\texttt{string}}) -- tells the format of the file with the standard notation for date and time and with variable
parts as ''?''. E.g. if the files are 56\_20150101.csv, 57\_20150102.csv etc filename\_format should be:
??\_\%Y\%m\%d.csv
this is useful primarily for the quality control feature.

\item {} 
\textbf{\texttt{units}} (\emph{\texttt{dictionary}}) -- very important: a dictionary whose keys are the columns of the file and whose items are
the units in which they appear.

\item {} 
\textbf{\texttt{description}} (\emph{\texttt{string}}) -- brief description of the datalogger configuration file.

\item {} 
\textbf{\texttt{varNames}} (\emph{\texttt{DEPRECATED}}) -- use variables now.

\end{itemize}

\end{description}\end{quote}
\index{get\_date\_cols() (pymicra.core.fileConfig method)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.fileConfig.get_date_cols}\pysiglinewithargsret{\sphinxbfcode{get\_date\_cols}}{}{}
Guesses what are the columns that contain the dates by searching
for percentage signs in them

\end{fulllineitems}


\end{fulllineitems}

\index{siteConfig (class in pymicra.core)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.siteConfig}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{pymicra.core.}\sphinxbfcode{siteConfig}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{object}

Keeps the configurations and constants of an experiment. (such as height of instruments,
location, canopy height and etc)

Check help(pm.siteConfig.\_\_init\_\_) for other parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{from\_file}} (\emph{\texttt{str}}) -- path to .site file which contais other keywords

\end{description}\end{quote}

\end{fulllineitems}



\section{pymicra.data}
\label{pymicra:pymicra-data}\label{pymicra:module-pymicra.data}\index{pymicra.data (module)}
Defines functions useful to generic signal data
\index{bulkCorr() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.bulkCorr}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{bulkCorr}}{\emph{data}}{}
Bulk correlation coefficient according

Bulk correlation coefficient according to
Cancelli, Dias, Chamecki. Dimensionless criteria for the production of...
doi:10.1029/2012WR012127
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{data}} (\emph{\texttt{pandas.dataframe}}) -- a two-columns dataframe

\end{description}\end{quote}

\end{fulllineitems}

\index{crossSpectra() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.crossSpectra}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{crossSpectra}}{\emph{data}, \emph{frequency=10}, \emph{notation=None}, \emph{anti\_aliasing=True}}{}
Calculates the spectrum for a set of data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame or pandas.Series}}) -- dataframe with one (will return the spectrum) or two (will return to cross-spectrum) columns

\item {} 
\textbf{\texttt{frequency}} (\emph{\texttt{float}}) -- frequency of measurement of signal to pass to numpy.fft.rfftfreq

\item {} 
\textbf{\texttt{anti\_aliasing}} (\emph{\texttt{bool}}) -- whether or not to apply anti-aliasing according to Gobbi, Chamecki \& Dias, 2006 (doi:10.1029/2005WR004374)

\item {} 
\textbf{\texttt{notation}} (\emph{\texttt{notation object}}) -- notation to be used

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{spectrum} -- whose column is the spectrum or coespectrum of the input dataframe

\item[{Return type}] \leavevmode
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{detrend() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.detrend}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{detrend}}{\emph{*args}, \emph{**kwargs}}{}
Returns the detrended fluctuations of a given dataset
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame, pandas.Series}}) -- dataset to be detrended

\item {} 
\textbf{\texttt{how}} (\emph{\texttt{string}}) -- how of average to apply. Currently \{`movingmean', `movingmedian', `block', `linear', `poly'\}.

\item {} 
\textbf{\texttt{rule}} (\emph{\texttt{pandas offset string}}) -- the blocks for which the trends should be calculated in the block and linear type

\item {} 
\textbf{\texttt{window}} (\emph{\texttt{pandas date offset string or int}}) -- if moving mean/median is chosen, this tells us the window size to pass to pandas. If int,
this is the number of points used in the window. If string we will to guess the number of
points from the index.
Small windows (equivalent to 1min approx) work better when using rollingmedian.

\item {} 
\textbf{\texttt{block\_func}} (\emph{\texttt{str, function}}) -- how to resample in block type. Default is mean but it can be any numpy function
that returns a float. E.g, median.

\item {} 
\textbf{\texttt{degree}} (\emph{\texttt{int}}) -- degree of polynomial fit (only if how=='linear' or how=='polynomial')

\end{itemize}

\item[{Returns}] \leavevmode
fluctuations of the input data

\item[{Return type}] \leavevmode
pandas.DataFrame or pandas.Series

\end{description}\end{quote}

\end{fulllineitems}

\index{reverse\_arrangement() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.reverse_arrangement}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{reverse\_arrangement}}{\emph{array}, \emph{points\_number=None}, \emph{alpha=0.05}, \emph{verbose=False}}{}
Performs the reverse arrangement test
according to Bendat and Piersol - Random Data - 4th edition, page 96
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{array}} (\emph{\texttt{np.array, list, tuple, generator}}) -- array which to test for the reverse arrangement test

\item {} 
\textbf{\texttt{points\_number}} (\emph{\texttt{integer}}) -- number of chunks to consider to the test. Maximum is the length of the array.
If it is less, then the number of points will be reduced by application of a mean

\item {} 
\textbf{\texttt{alpha}} (\emph{\texttt{float}}) -- Significance level for which to apply the test

\item {} 
\textbf{\texttt{This fuction approximates table A.6 from Bendat\&Piersol as a normal distribution.}} (\emph{\texttt{WARNING!}}) -- 

\item {} 
\textbf{\texttt{may no be true, since they do not express which distribution they use to construct}} (\emph{\texttt{This}}) -- 

\item {} 
\textbf{\texttt{table. However, in the range 9\textless{}N\textless{}101, this approximation is as good as 5\% at N=10}} (\emph{\texttt{their}}) -- 

\item {} 
\textbf{\texttt{0.1\% at N=100.}} (\emph{\texttt{and}}) -- 

\item {} 
\textbf{\texttt{not adapted for dataframes}} (\emph{\texttt{Still}}) -- 

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{rotate2D() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.rotate2D}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{rotate2D}}{\emph{data}, \emph{notation=None}}{}
Rotates the coordinates of wind data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas DataFrame}}) -- the dataFrame to be rotated

\item {} 
\textbf{\texttt{notation}} (\emph{\texttt{notation object}}) -- a notation object to know which are the wind variables

\end{itemize}

\item[{Returns}] \leavevmode
the complete data input with the wind components rotated

\item[{Return type}] \leavevmode
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{spectra() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.spectra}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{spectra}}{\emph{*args}, \emph{**kwargs}}{}
Calculates the cross-spectra for a set of data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame or pandas.Series}}) -- dataframe with more than one columns

\item {} 
\textbf{\texttt{frequency}} (\emph{\texttt{float}}) -- frequency of measurement of signal to pass to numpy.fft.rfftfreq

\item {} 
\textbf{\texttt{anti\_aliasing}} (\emph{\texttt{bool}}) -- whether or not to apply anti-aliasing according to Gobbi, Chamecki \& Dias, 2006 (doi:10.1029/2005WR004374)

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{spectra} -- whose column is the spectrum or coespectrum of the input dataframe

\item[{Return type}] \leavevmode
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{trend() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.trend}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{trend}}{\emph{*args}, \emph{**kwargs}}{}
Wrapper to return the trend given data. Can be achieved using a moving avg, block avg or polynomial fitting
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame or pandas.Series}}) -- the data whose trend wee seek.

\item {} 
\textbf{\texttt{how}} (\emph{\texttt{string}}) -- how of average to apply. Currently \{`movingmean', `movingmedian', `block', `linear'\}.

\item {} 
\textbf{\texttt{rule}} (\emph{\texttt{string}}) -- pandas offset string to define the block in the block average. Default is ``10min''.

\item {} 
\textbf{\texttt{window}} (\emph{\texttt{pandas date offset string or int}}) -- if moving mean/median is chosen, this tells us the window size to pass to pandas. If int,
this is the number of points used in the window. If string we will to guess the number of
points from the index.
Small windows (equivalent to 1min approx) work better when using rollingmedian.

\item {} 
\textbf{\texttt{block\_func}} (\emph{\texttt{str, function}}) -- how to resample in block type. Default is mean but it can be any numpy function
that returns a float. E.g, median.

\item {} 
\textbf{\texttt{degree}} (\emph{\texttt{int}}) -- degree of polynomial fit (only if how=='linear' or how=='polynomial')

\end{itemize}

\item[{Returns}] \leavevmode
trends of data input

\item[{Return type}] \leavevmode
pandas.DataFrame or pandas.Series

\end{description}\end{quote}

\end{fulllineitems}



\section{pymicra.decorators}
\label{pymicra:pymicra-decorators}\label{pymicra:module-pymicra.decorators}\index{pymicra.decorators (module)}
Defines useful decorators for Pymicra
\index{autoassign() (in module pymicra.decorators)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.decorators.autoassign}\pysiglinewithargsret{\sphinxcode{pymicra.decorators.}\sphinxbfcode{autoassign}}{\emph{*names}, \emph{**kwargs}}{}
Decorator that automatically assigns keywords as atributes

allow a method to assign (some of) its arguments as attributes of
`self' automatically.  E.g.

To restrict autoassignment to `bar' and `baz', write:

@autoassign(`bar', `baz')
def method(self, foo, bar, baz): ...

To prevent `foo' and `baz' from being autoassigned, use:

@autoassign(exclude=(`foo', `baz'))
def method(self, foo, bar, baz): ...

\end{fulllineitems}

\index{pdgeneral() (in module pymicra.decorators)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.decorators.pdgeneral}\pysiglinewithargsret{\sphinxcode{pymicra.decorators.}\sphinxbfcode{pdgeneral}}{\emph{convert\_out=True}}{}
Defines a decorator to make functions work on both pandas.Series and DataFrames
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{convert\_out}} (\emph{\texttt{bool}}) -- if True, also converts output back to Series if input is Series

\end{description}\end{quote}

\end{fulllineitems}

\index{pdgeneral\_in() (in module pymicra.decorators)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.decorators.pdgeneral_in}\pysiglinewithargsret{\sphinxcode{pymicra.decorators.}\sphinxbfcode{pdgeneral\_in}}{\emph{func}}{}
Defines a decorator that transforms Series into DataFrame

\end{fulllineitems}

\index{pdgeneral\_io() (in module pymicra.decorators)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.decorators.pdgeneral_io}\pysiglinewithargsret{\sphinxcode{pymicra.decorators.}\sphinxbfcode{pdgeneral\_io}}{\emph{func}}{}
If the input is a series transform it to a dtaframe then transform the output from dataframe
back into a series. If the input is a series and the output is a one-element series, transform it to a float.

Currently the output functionality works only when the output is one variable, not an array
of elements.

\end{fulllineitems}



\section{pymicra.io}
\label{pymicra:pymicra-io}\label{pymicra:module-pymicra.io}\index{pymicra.io (module)}
Defines some useful functions to aid on the input/output of data
\index{readDataFile() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.readDataFile}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{readDataFile}}{\emph{fname}, \emph{variables=None}, \emph{only\_named\_cols=True}, \emph{**kwargs}}{}
Reads one datafile using pandas.read\_csv()
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{variables}} (\emph{\texttt{list or dict}}) -- keys are columns and values are names of variable

\item {} 
\textbf{\texttt{only\_named\_columns}} (\emph{\texttt{bool}}) -- if True, don't read columns that don't appear on variables' keys

\item {} 
\textbf{\texttt{kwargs}} (\emph{\texttt{dict}}) -- dictionary with kwargs of pandas' read\_csv function
see \url{http://pandas.pydata.org/pandas-docs/stable/generated/pandas.read\_csv.html} for more detail

\item {} 
\textbf{\texttt{variables}} -- list or dictionary containing the names of each variable in the file (if dict, the keys must be ints)

\end{itemize}

\item[{Returns}] \leavevmode
pandas.DataFrame object

\item[{Return type}] \leavevmode
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{readDataFiles() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.readDataFiles}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{readDataFiles}}{\emph{flist}, \emph{verbose=0}, \emph{**kwargs}}{}
Reads data from a list of files by calling readDataFile individually for each entry
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{flist}} (\emph{\texttt{sequence of strings}}) -- files to be parsed

\item {} 
\textbf{\texttt{verbose}} (\emph{\texttt{bool}}) -- whether to print

\item {} 
\textbf{\texttt{**kwargs}} -- readDataFile kwargs

\end{itemize}

\item[{Returns}] \leavevmode
data

\item[{Return type}] \leavevmode
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{readUnitsCsv() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.readUnitsCsv}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{readUnitsCsv}}{\emph{filename}, \emph{**kwargs}}{}
Reads a csv file in which the first line is the name of the variables
and the second line contains the units
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filename}} (\emph{\texttt{string}}) -- path of the csv file to read

\item {} 
\textbf{\texttt{**kwargs}} -- to be passed to pandas.read\_csv

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\textbf{df} (\emph{pandas.DataFrame}) -- dataframe with the data

\item {} 
\textbf{unitsdic} (\emph{dictionary}) -- dictionary with the variable names as keys and the units as values

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{read\_fileConfig() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.read_fileConfig}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{read\_fileConfig}}{\emph{dlcfile}}{}
Reads metadata configuration file

WARNING! When defining the .config file note that by default columns that are enclosed between doublequotes
will appear without the doublequotes. So if your file is of the form :

``2013-04-05 00:00:00'', .345, .344, ...

Then the .config should have: variables=\{0:'\%Y-\%m-\%d \%H:\%M:\%S',1:'u',2:'v'\}. This is the default csv format of
CampbellSci dataloggers. To disable this feature, you should parse the file with read\_csv using the kw: quoting=3.

\end{fulllineitems}

\index{read\_site() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.read_site}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{read\_site}}{\emph{sitefile}}{}
Reads .site configuration file, which holds siteConfig definitions
\begin{description}
\item[{The .site should have definitions as regular python syntax (in meters!):}] \leavevmode
measurement\_height  = 10
canopy\_height       = 5
displacement\_height = 3
roughness\_length    = 1.0

\item[{sitedile: str}] \leavevmode
path to .site file

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{sitefile}} (\emph{\texttt{str}}) -- path to the site configuration file

\item[{Returns}] \leavevmode
pymicra site configuration object

\item[{Return type}] \leavevmode
pymicra.siteConfig

\end{description}\end{quote}

\end{fulllineitems}

\index{timeSeries() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.timeSeries}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{timeSeries}}{\emph{flist}, \emph{datalogger}, \emph{parse\_dates=True}, \emph{verbose=False}, \emph{read\_data\_kw=\{\}}, \emph{parse\_dates\_kw=\{\}}, \emph{clean\_dates=True}, \emph{return\_units=True}, \emph{only\_named\_cols=True}}{}
Creates a micrometeorological time series from a file or list of files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{flist}} (\emph{\texttt{list or string}}) -- either list or names of files (dataFrame will be one concatenated dataframe) or the name of one file

\item {} 
\textbf{\texttt{datalogger}} (\emph{\texttt{pymicra.dataloggerConfig object}}) -- configuration of the datalogger which is from where all the configurations of the file will be taken

\item {} 
\textbf{\texttt{parse\_date}} (\emph{\texttt{bool}}) -- whether or not to index the data by date. Note that if this is False many of the functionalities
of pymicra will be lost.
(i.d. there are repeated timestamps)

\item {} 
\textbf{\texttt{verbose}} (\emph{\texttt{int, bool}}) -- verbose level

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\emph{pandas.DataFrame} -- data contained in the files in flist

\item {} 
\emph{dict (optional)} -- units of the data

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\section{pymicra.methods}
\label{pymicra:module-pymicra.methods}\label{pymicra:pymicra-methods}\index{pymicra.methods (module)}
Defines some methods. Some have functions defined here but most use
functions defined elsewhere. This is done by monkey-patching Pandas.
\index{binwrapper() (in module pymicra.methods)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.methods.binwrapper}\pysiglinewithargsret{\sphinxcode{pymicra.methods.}\sphinxbfcode{binwrapper}}{\emph{self}, \emph{clean\_index=True}, \emph{**kwargs}}{}
Method to return binned data from a dataframe using the function classbin

\end{fulllineitems}



\section{pymicra.physics}
\label{pymicra:module-pymicra.physics}\label{pymicra:pymicra-physics}\index{pymicra.physics (module)}
Module that contains physical functions. They are all general use, but
most are specially frequent in micrometeorology.
\begin{description}
\item[{TO DO LIST:}] \leavevmode\begin{itemize}
\item {} 
ADD GENERAL SOLAR ZENITH CALCULATION

\item {} 
ADD FOOTPRINT CALCULATION?

\end{itemize}

\end{description}
\index{R\_moistAir() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.R_moistAir}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{R\_moistAir}}{\emph{q}}{}
Calculates the gas constant for umid air from the specific humidity q
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{q}} (\emph{\texttt{float}}) -- the specific humidity in g(water)/g(air)

\item[{Returns}] \leavevmode
\textbf{R\_air} -- the specific gas constant for humid air in J/(g*K)

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{airDensity\_from\_theta() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.airDensity_from_theta}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{airDensity\_from\_theta}}{\emph{data}, \emph{units}, \emph{notation=None}, \emph{inplace\_units=True}, \emph{use\_means=False}, \emph{theta=None}, \emph{theta\_unit=None}}{}
Calculates moist air density using theta measurements
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame}}) -- dataset to add rho\_air

\item {} 
\textbf{\texttt{units}} (\emph{\texttt{dict}}) -- units dictionary

\item {} 
\textbf{\texttt{notation}} (\emph{\texttt{pymicra.notation}}) -- notation to be used

\item {} 
\textbf{\texttt{inplace\_units}} (\emph{\texttt{bool}}) -- whether or not to treat units inplace

\item {} 
\textbf{\texttt{use\_means}} (\emph{\texttt{bool}}) -- use the mean of theta or not when calculating

\item {} 
\textbf{\texttt{theta}} (\emph{\texttt{pandas.Series}}) -- auxiliar theta measurement

\item {} 
\textbf{\texttt{theta\_unit}} (\emph{\texttt{pint.quantity}}) -- auxiliar theta's unit

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{airDensity\_from\_theta\_v() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.airDensity_from_theta_v}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{airDensity\_from\_theta\_v}}{\emph{data}, \emph{units}, \emph{notation=None}, \emph{inplace\_units=True}, \emph{use\_means=False}, \emph{return\_full\_df=True}}{}
Calculates moist air density using p = rho R\_dry T\_virtual
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame}}) -- data to use to calculate air density

\item {} 
\textbf{\texttt{units}} (\emph{\texttt{dict}}) -- dictionary of units

\item {} 
\textbf{\texttt{notation}} (\emph{\texttt{pymicra.Notation}}) -- notation to be used

\item {} 
\textbf{\texttt{inplace\_units}} (\emph{\texttt{bool}}) -- whether or not to update the units inplace. If False, units are returns too

\item {} 
\textbf{\texttt{use\_means}} (\emph{\texttt{bool}}) -- whether or not to use averages of pressure and virtual temperature, instead of the means plus fluctuations

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{dewPointTemp() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.dewPointTemp}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{dewPointTemp}}{\emph{theta}, \emph{e}}{}
Calculates the dew point temperature.
theta has to be in Kelvin and e in kPa

\end{fulllineitems}

\index{dryAirDensity\_from\_p() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.dryAirDensity_from_p}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{dryAirDensity\_from\_p}}{\emph{data}, \emph{units}, \emph{notation=None}, \emph{inplace\_units=True}}{}
Calculates dry air density
NEEDS IMPROVEMENT REGARDING HANDLING OF UNITS

\end{fulllineitems}

\index{latent\_heat\_water() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.latent_heat_water}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{latent\_heat\_water}}{\emph{T}}{}
Calculates the latent heat of evaporation for water

Receives T in Kelvin and returns the latent heat in J/g

\end{fulllineitems}

\index{perfGas() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.perfGas}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{perfGas}}{\emph{p=None}, \emph{rho=None}, \emph{R=None}, \emph{T=None}, \emph{gas=None}}{}
Returns the only value that is not provided in the ideal gas law

P.S.: I'm using type to identify None objects because this way it works
againt pandas objects

\end{fulllineitems}

\index{ppxv2density() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.ppxv2density}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{ppxv2density}}{\emph{data}, \emph{units}, \emph{notation=None}, \emph{inplace\_units=True}, \emph{solutes={[}{]}}}{}
Calculates density of solutes based on their molar concentration (ppmv, ppbv and etc), not
to be confused with mass concentration (ppm, ppb and etc).

Uses the relation
\(\rho_x = \frac{C p}{\theta R_x}\)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame}}) -- dataset of micromet variables

\item {} 
\textbf{\texttt{units}} (\emph{\texttt{dict}}) -- dict of pint units

\item {} 
\textbf{\texttt{notation}} (\emph{\texttt{pymicra.Notation}}) -- notation to be used here

\item {} 
\textbf{\texttt{inplace\_units}} (\emph{\texttt{bool}}) -- whether or not to treat the dict units in place

\item {} 
\textbf{\texttt{solutes}} (\emph{\texttt{list or tuple}}) -- solutes to consider when doing this conversion

\end{itemize}

\item[{Returns}] \leavevmode
input data plus calculated density columns

\item[{Return type}] \leavevmode
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{satWaterPressure() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.satWaterPressure}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{satWaterPressure}}{\emph{T}, \emph{unit='kelvin'}}{}
Returns the saturated water vapor pressure according eq (3.97) of Wallace and Hobbes, page 99.

e0, b, T1 and T2 are constants specific for water vapor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{T}} (\emph{\texttt{float}}) -- thermodynamic temperature

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
saturated vapor pressure of water (in kPa)

\end{description}\end{quote}

\end{fulllineitems}

\index{theta\_from\_theta\_s() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.theta_from_theta_s}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{theta\_from\_theta\_s}}{\emph{data}, \emph{units}, \emph{notation=None}, \emph{return\_full\_df=True}, \emph{inplace\_units=True}}{}
Calculates thermodynamic temperature using sonic temperature measurements

From Schotanus, Nieuwstadt, de Bruin; DOI 10.1007/BF00164332

theta\_s = theta (1 + 0.51 q) (1 - (vn/c)**2)\textasciicircum{}0.5

\(theta_s \approx theta (1 + 0.51 q)\)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.dataframe}}) -- dataset

\item {} 
\textbf{\texttt{units}} (\emph{\texttt{dict}}) -- units dictionary

\item {} 
\textbf{\texttt{notation}} (\emph{\texttt{pymicra.Notation}}) -- 

\end{itemize}

\item[{Returns}] \leavevmode
thermodynamic temperature

\item[{Return type}] \leavevmode
pandas.Series

\end{description}\end{quote}

\end{fulllineitems}

\index{theta\_from\_theta\_v() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.theta_from_theta_v}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{theta\_from\_theta\_v}}{\emph{data}, \emph{units}, \emph{notation=None}, \emph{return\_full\_df=True}, \emph{inplace\_units=True}}{}
Calculates thermodynamic temperature from virtual temperature measurements

\(theta_v \approx theta (1 + 0.61 q)\)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.dataframe}}) -- dataset

\item {} 
\textbf{\texttt{units}} (\emph{\texttt{dict}}) -- units dictionary

\item {} 
\textbf{\texttt{notation}} (\emph{\texttt{pymicra.Notation}}) -- 

\end{itemize}

\item[{Returns}] \leavevmode
virtual temperature

\item[{Return type}] \leavevmode
pandas.DataFrame or Series

\end{description}\end{quote}

\end{fulllineitems}

\index{theta\_std\_from\_theta\_v\_fluc() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.theta_std_from_theta_v_fluc}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{theta\_std\_from\_theta\_v\_fluc}}{\emph{data}, \emph{units}, \emph{notation=None}}{}
Derived from theta\_v = theta(1 + 0.61 q)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.dataframe}}) -- dataframe with q, q', theta, theta\_v'

\item {} 
\textbf{\texttt{units}} (\emph{\texttt{dict}}) -- units dictionary

\item {} 
\textbf{\texttt{notation}} (\emph{\texttt{pymicra.Notation}}) -- Notation object or None

\end{itemize}

\item[{Returns}] \leavevmode
standard deviation of the thermodynamic temperature

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\section{pymicra.tests}
\label{pymicra:pymicra-tests}\label{pymicra:module-pymicra.tests}\index{pymicra.tests (module)}
This module contains functions that test certain conditions on pandas.dataframes to
be used with the qcontrol().

They all return True for the columns that pass the test and False for the columns
that fail the test.
\index{check\_RA() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_RA}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_RA}}{\emph{data}, \emph{detrend=True}, \emph{detrend\_kw=\{`how': `linear'\}}, \emph{RAT\_vars=None}, \emph{RAT\_points=50}, \emph{RAT\_significance=0.05}}{}
Performs the Reverse Arrangement Test in each column of data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame}}) -- to apply RAT to each column

\item {} 
\textbf{\texttt{detrend\_kw}} (\emph{\texttt{dict}}) -- keywords to pass to pymicra.detrend

\item {} 
\textbf{\texttt{RAT\_vars}} -- list of variables to which apply the RAT

\item {} 
\textbf{\texttt{RAT\_points}} (\emph{\texttt{int}}) -- if it's an int N, then reduce each column to N points by averaging. If None,
then the whole columns are used

\item {} 
\textbf{\texttt{RAT\_significance}} (\emph{\texttt{float}}) -- significance with which to apply the RAT

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{valid} -- True or False for each column. If True, column passed the test

\item[{Return type}] \leavevmode
pd.Series

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_limits() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_limits}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_limits}}{\emph{data}, \emph{tables}, \emph{max\_percent=1.0}, \emph{replace\_with='interpolation'}}{}
Checks dataframe for lower and upper limits. If found, they are substituted by
the linear trend of the run. The number of faulty points is also checked for each
column against the maximum percentage of accepted faults max\_percent
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas dataframe}}) -- dataframe to be checked

\item {} 
\textbf{\texttt{tables}} (\emph{\texttt{pandas.dataframe}}) -- dataframe with the lower and upper limits for variables

\item {} 
\textbf{\texttt{max\_percent}} (\emph{\texttt{float}}) -- number from 0 to 100 that represents the maximum percentage of faulty
runs accepted by this test.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\textbf{df} (\emph{pandas.DataFrame}) -- input data but with the faulty points substituted by the linear trend of the run.

\item {} 
\textbf{valid} (\emph{pandas.Series}) -- True for the columns that passed this test, False for the columns that didn't.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{check\_maxdif() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_maxdif}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_maxdif}}{\emph{data}, \emph{tables}, \emph{detrend=True}, \emph{detrend\_kw=\{`how': `movingmean'}, \emph{`window': 900\}}}{}
Check the maximum and minimum differences between the fluctuations of a run.

\end{fulllineitems}

\index{check\_nans() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_nans}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_nans}}{\emph{data}, \emph{max\_percent=0.1}, \emph{replace\_with='interpolation'}}{}
Checks data for NaN values

\end{fulllineitems}

\index{check\_numlines() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_numlines}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_numlines}}{\emph{fname}, \emph{numlines=18000}, \emph{falseverbose=False}}{}
Checks length of file against a correct value.
Returns False is length is wrong and True if length is right
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{fname}} (\emph{\texttt{string}}) -- path of the file to check

\item {} 
\textbf{\texttt{numlines}} (\emph{\texttt{int}}) -- correct number of lines that the file has to have

\end{itemize}

\item[{Returns}] \leavevmode
Either with True or False

\item[{Return type}] \leavevmode
pandas.Series

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_replaced() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_replaced}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_replaced}}{\emph{replaced}, \emph{max\_count=180}}{}
Sums and checks if the number of replaced points is larger than the
maximum accepted

\end{fulllineitems}

\index{check\_spikes() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_spikes}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_spikes}}{\emph{data}, \emph{chunk\_size=`2min'}, \emph{detrend=True}, \emph{detrend\_kw=\{`how': `linear'\}}, \emph{visualize=False}, \emph{vis\_col=1}, \emph{max\_consec\_spikes=3}, \emph{cut\_func=\textless{}function \textless{}lambda\textgreater{}\textgreater{}}, \emph{replace\_with='interpolation'}, \emph{max\_percent=1.0}}{}
Applies spikes-check according to Vickers and Mahrt (1997)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.dataframe}}) -- data to de-spike

\item {} 
\textbf{\texttt{chunk\_size}} (\emph{\texttt{str, int}}) -- size of chunks to consider. If str should be pandas offset string. If int, number of lines.

\item {} 
\textbf{\texttt{detrend}} (\emph{\texttt{bool}}) -- whether to detrend the data and work  with the fluctuations or to work with the absolute series.

\item {} 
\textbf{\texttt{detrend\_kw}} (\emph{\texttt{dict}}) -- dict of keywords to pass to pymicra.trend in order to detrend data (if detrend==True).

\item {} 
\textbf{\texttt{visualize}} (\emph{\texttt{bool}}) -- whether of not to visualize the interpolation ocurring

\item {} 
\textbf{\texttt{vis\_col}} (\emph{\texttt{str, int or list}}) -- the column(s) to visualize when seeing the interpolation (only effective if visualize==True)

\item {} 
\textbf{\texttt{max\_consec\_spikes}} (\emph{\texttt{int}}) -- maximum number of consecutive spikes to actually be considered spikes and substituted

\item {} 
\textbf{\texttt{cut\_func}} (\emph{\texttt{function}}) -- function used to define spikes

\item {} 
\textbf{\texttt{replace\_with}} (\emph{\texttt{str}}) -- method to use when replacing spikes. Options are `interpolation' or `trend'.

\item {} 
\textbf{\texttt{max\_percent}} (\emph{\texttt{float}}) -- maximum percentage of spikes to allow.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_stationarity() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_stationarity}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_stationarity}}{\emph{data}, \emph{tables}, \emph{detrend=False}, \emph{detrend\_kw=\{`how': `movingmean'}, \emph{`window': 900\}}, \emph{trend=True}, \emph{trend\_kw=\{`how': `movingmedian'}, \emph{`window': `1min'\}}}{}
Check difference between the maximum and minimum values of the run trend agaisnt an upper-limit.
This aims to flag nonstationary runs

\end{fulllineitems}

\index{check\_std() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_std}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_std}}{\emph{data}, \emph{tables}, \emph{detrend=False}, \emph{detrend\_kw=\{`how': `linear'\}}, \emph{chunk\_size=`2min'}, \emph{falseverbose=False}}{}
Checks dataframe for columns with too small of a standard deviation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame}}) -- dataset whose standard deviation to check

\item {} 
\textbf{\texttt{tables}} (\emph{\texttt{pandas.DataFrame}}) -- dataset containing the standard deviation limits for each column

\item {} 
\textbf{\texttt{detrend}} (\emph{\texttt{bool}}) -- whether to work with the absolute series and the fluctuations

\item {} 
\textbf{\texttt{detrend\_kw}} (\emph{\texttt{dict}}) -- keywords to pass to pymicra.detrend with detrend==True

\item {} 
\textbf{\texttt{chunk\_size}} (\emph{\texttt{str}}) -- pandas datetime offset string

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{valid} -- contatining True of False for each column. True means passed the test.

\item[{Return type}] \leavevmode
pandas.Series

\end{description}\end{quote}

\end{fulllineitems}



\section{pymicra.util}
\label{pymicra:pymicra-util}\label{pymicra:module-pymicra.util}\index{pymicra.util (module)}
Module for general utilities
\begin{itemize}
\item {} 
INCLUDE DECODIFICAION OF DATA?

\item {} 
INCLUDE UPPER LIMIT TO STD TEST?

\item {} 
INCLUDE DROPOUT TEST

\item {} 
INCLUDE THIRD MOMENT TEST

\item {} 
CHANGE NOTATION IN QCONTROL'S SUMMARY

\end{itemize}
\index{correctDrift() (in module pymicra.util)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.util.correctDrift}\pysiglinewithargsret{\sphinxcode{pymicra.util.}\sphinxbfcode{correctDrift}}{\emph{drifted}, \emph{correct\_drifted\_vars=None}, \emph{correct=None}, \emph{get\_fit=True}, \emph{write\_fit=True}, \emph{fit\_file='correctDrift\_linfit.params'}, \emph{apply\_fit=True}, \emph{show\_plot=False}, \emph{return\_plot=False}, \emph{units=\{\}}, \emph{return\_index=False}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{correct}} (\emph{\texttt{pandas.DataFrame}}) -- dataset with the correct averages

\item {} 
\textbf{\texttt{drifted}} (\emph{\texttt{pandas.DataFrame}}) -- dataset with the averages that need to be corrected

\item {} 
\textbf{\texttt{correct\_drifted\_vars}} (\emph{\texttt{dict}}) -- dictionary where every key is a var in the right dataset and
its value is its correspondent in the drifted dataset

\item {} 
\textbf{\texttt{get\_fit}} (\emph{\texttt{bool}}) -- whether ot not to fit a linear relation between both datasets. Generally slow. Should only be done once

\item {} 
\textbf{\texttt{write\_fit}} (\emph{\texttt{bool}}) -- if get\_fit == True, whether or not to write the linear fit to a file (recommended)

\item {} 
\textbf{\texttt{fit\_file}} (\emph{\texttt{string}}) -- where to write the linear fit (if one is written) or from where to read the linear fit (if no fit is written)

\item {} 
\textbf{\texttt{apply\_fit}} (\emph{\texttt{bool}}) -- whether of not to apply the lineat fit and correct the data (at least get\_fit and fit\_file must be true)

\item {} 
\textbf{\texttt{show\_plot}} (\emph{\texttt{bool}}) -- whether or not to show drifted vs correct plot, to see if it's a good fit

\item {} 
\textbf{\texttt{units}} (\emph{\texttt{dict}}) -- if given, it creates a \{file\_file\}.units file, to tell write down in which units data has to be in
order to be correctly corrected

\item {} 
\textbf{\texttt{return\_index}} (\emph{\texttt{bool}}) -- whether to return the indexes of the used points for the calculation. Serves to check the regression

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{outdf} -- drifted dataset corrected with right dataset

\item[{Return type}] \leavevmode
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{qcontrol() (in module pymicra.util)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.util.qcontrol}\pysiglinewithargsret{\sphinxcode{pymicra.util.}\sphinxbfcode{qcontrol}}{\emph{files}, \emph{datalogger\_config}, \emph{read\_files\_kw=\{`return\_units': False}, \emph{`parse\_dates': False}, \emph{`only\_named\_cols': False}, \emph{`clean\_dates': False\}}, \emph{accepted\_nans\_percent=1.0}, \emph{accepted\_spikes\_percent=1.0}, \emph{accepted\_bound\_percent=1.0}, \emph{max\_replacement\_count=180}, \emph{file\_lines=None}, \emph{begin\_date=None}, \emph{end\_date=None}, \emph{nans\_test=True}, \emph{maxdif\_detrend=True}, \emph{maxdif\_detrend\_kw=\{`how': `movingmean'}, \emph{`window': 900\}}, \emph{maxdif\_trend=True}, \emph{maxdif\_trend\_kw=\{`how': `movingmedian'}, \emph{`window': 600\}}, \emph{std\_detrend=True}, \emph{std\_detrend\_kw=\{`how': `movingmean'}, \emph{`window': 900\}}, \emph{RAT\_detrend=True}, \emph{RAT\_detrend\_kw=\{`how': `linear'\}}, \emph{spikes\_detrend=True}, \emph{spikes\_detrend\_kw=\{`how': `linear'\}}, \emph{lower\_limits=\{\}}, \emph{upper\_limits=\{\}}, \emph{spikes\_test=True}, \emph{visualize\_spikes=False}, \emph{spikes\_vis\_col='u'}, \emph{spikes\_func=\textless{}function \textless{}lambda\textgreater{}\textgreater{}}, \emph{replace\_with='interpolation'}, \emph{max\_consec\_spikes=3}, \emph{chunk\_size=1200}, \emph{std\_limits=\{\}}, \emph{dif\_limits=\{\}}, \emph{RAT=False}, \emph{RAT\_vars=None}, \emph{RAT\_points=50}, \emph{RAT\_significance=0.05}, \emph{trueverbose=False}, \emph{falseverbose=True}, \emph{falseshow=False}, \emph{trueshow=False}, \emph{trueshow\_vars=None}, \emph{outdir='quality\_controlled'}, \emph{summary\_file='qcontrol\_summary.csv'}, \emph{replaced\_report=None}, \emph{full\_report=None}}{}
Function that applies various tests quality control to a set of datafiles and re-writes
the successful files in another directory. A list of currently-applied tests is found
below in order of application. The only test available by default is the spikes test.
All others depend on their respective keywords.
\begin{itemize}
\item {} \begin{quote}\begin{description}
\item[{date check}] \leavevmode
files outside a date\_range are left out (end\_date and begin\_date keywords)

\end{description}\end{quote}

\item {} \begin{quote}\begin{description}
\item[{lines test}] \leavevmode
checks each file to see if they have a certain number of lines. Files with a different number of lines
fail this test. Active this test by passing the file\_lines keyword.

\end{description}\end{quote}

\end{itemize}
\begin{itemize}
\item {} \begin{quote}\begin{description}
\item[{NaN's test}] \leavevmode
checks for any NaN values. NaNs are replaced with interpolation or linear trend. If the percentage
of NaNs is greater than accepted\_nans\_percent, run is discarded. Activate it by passing nans\_test=True.

\end{description}\end{quote}

\item {} \begin{quote}\begin{description}
\item[{boundaries test}] \leavevmode
runs with values in any column lower than a pre-determined lower limit or higher
than a upper limits are left out. Activate it by passing a lower\_limits or upper\_limits keyword.

\end{description}\end{quote}

\item {} \begin{quote}\begin{description}
\item[{spikes test}] \leavevmode
runs with more than a certain percetage of spikes are left out.
Activate it by passing a spikes\_test keyword. Adjust the test with the spikes\_func
visualize\_spikes, spikes\_vis\_col, max\_consec\_spikes, accepted\_spikes\_percent and chunk\_size keywords.

\end{description}\end{quote}

\item {} \begin{quote}\begin{description}
\item[{replacement count test}] \leavevmode
checks the total amount of points that were replaced (including NaN, boundaries and spikes test)
against the max\_replacement\_count keyword. Fails if any columns has more replacements than that.

\end{description}\end{quote}

\item {} \begin{quote}\begin{description}
\item[{standard deviation (STD) check}] \leavevmode
runs with a standard deviation lower than a pre-determined value (generally close to the
sensor precision) are left out.
Activate it by passing a std\_limits keyword.

\end{description}\end{quote}

\item {} \begin{quote}\begin{description}
\item[{maximum difference test}] \leavevmode
runs whose trend have a maximum difference greater than a certain value are left out.
This excludes non-stationary runs. Activate it by passing a dif\_limits keyword.

\end{description}\end{quote}

\item {} \begin{quote}\begin{description}
\item[{reverse arrangement test (RAT)}] \leavevmode
runs that fail the reverse arrangement test for any variable are left out.
Activate it by passing a RAT keyword.

\end{description}\end{quote}

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{files}} (\emph{\texttt{list}}) -- list of filepaths

\item {} 
\textbf{\texttt{datalogger\_config}} (\emph{\texttt{pymicra.datalogerConf object or str}}) -- datalogger configuration object used for all files in the list of files or path to a dlc file.

\item {} 
\textbf{\texttt{read\_files\_kw}} (\emph{\texttt{dict}}) -- keywords to pass to pymicra.timeSeries. Default is \{`parse\_dates':False\} because parsing dates
at every file is slow, so this makes the whole process faster.
However, \{`parse\_dates':True, `clean\_dates':False\} is recommended if time is not a problem because
the window and chunk\_size keywords may be used as, for example `2min', instead of 1200, which is the
equivalent number of points.

\item {} 
\textbf{\texttt{file\_lines}} (\emph{\texttt{int}}) -- number of line a ``good'' file must have. Fails if the run has any other number of lines.

\item {} 
\textbf{\texttt{begin\_date}} (\emph{\texttt{str}}) -- dates before this automatically fail.

\item {} 
\textbf{\texttt{end\_date}} (\emph{\texttt{str}}) -- dates after this automatically fail.

\item {} 
\textbf{\texttt{std\_limits}} (\emph{\texttt{dict}}) -- keys must be names of variables and values must be upper limits for the standard deviation.

\item {} 
\textbf{\texttt{std\_detrend}} (\emph{\texttt{bool}}) -- whether or not to work with the fluctations of the data on the spikes and standard deviation test.

\item {} 
\textbf{\texttt{std\_detrend\_kw}} -- keywords to be passed to pymicra.detrend specifically to be used on the STD test.

\item {} 
\textbf{\texttt{lower\_limits}} (\emph{\texttt{dict}}) -- keys must be names of variables and values must be lower absolute limits for the values of each var.

\item {} 
\textbf{\texttt{upper\_limits}} (\emph{\texttt{dict}}) -- keys must be names of variables and values must be upper absolute limits for the values of each var.

\item {} 
\textbf{\texttt{dif\_limits}} (\emph{\texttt{dict}}) -- keys must be names of variables and values must be upper limits for the maximum difference
of values that the linear trend of the run must have.

\item {} 
\textbf{\texttt{maxdif\_detrend}} (\emph{\texttt{bool}}) -- whether to detrend data before checking for differences.

\item {} 
\textbf{\texttt{maxdif\_detrend\_kw}} (\emph{\texttt{dict}}) -- keywords to pass to pymicra.detrend when detrending for max difference test.

\item {} 
\textbf{\texttt{maxdif\_trend}} (\emph{\texttt{bool}}) -- whether to check for differences using the trend, instead of raw points (which can be the fluctuations
or the original absolute values of data, depending if maxdif\_detrend==True or False).

\item {} 
\textbf{\texttt{maxdif\_trend\_kw}} (\emph{\texttt{dict}}) -- keywords to pass to pymicra.detrend when trending for max difference test.
dictionary of keywords to pass to pymicra.data.trend. This is used in the max difference test, since
the difference is taken between the max and min values of the trend, not of the series.
Default = \{`how':'linear'\}.

\item {} 
\textbf{\texttt{spikes\_test}} (\emph{\texttt{bool}}) -- whether or not to check for spikes.

\item {} 
\textbf{\texttt{spikes\_detrend}} (\emph{\texttt{bool}}) -- whether or not to work with the fluctations of the data on the spikes test.

\item {} 
\textbf{\texttt{spikes\_detrend\_kw}} (\emph{\texttt{dict}}) -- keywords to pass to pymicra.detrend when detrending for spikes.

\item {} 
\textbf{\texttt{visualize\_spikes}} (\emph{\texttt{bool}}) -- whether or not to plot the spikes identification and interpolation (useful for calibration of spikes\_func). Only
one column is visualized at each time. This is set with the spikes\_vis\_col keyword.

\item {} 
\textbf{\texttt{spikes\_vis\_col}} (\emph{\texttt{str}}) -- column to use to visualize spikes.

\item {} 
\textbf{\texttt{spikes\_func}} (\emph{\texttt{function}}) -- function used to look for spikes. Can be defined used numpy/pandas notation for methods with lambda functions.
Default is: lambda x: (abs(x - x.mean()) \textgreater{} abs(x.std()*4.))

\item {} 
\textbf{\texttt{replace\_with}} (\emph{\texttt{str}}) -- method to use when replacing the spikes. Options are `interpolation' and `trend'.

\item {} 
\textbf{\texttt{max\_consec\_spikes}} (\emph{\texttt{int}}) -- limit of consecutive spike points to be interpolated. After this spikes are left as they are in the output.

\item {} 
\textbf{\texttt{accepted\_percent}} (\emph{\texttt{float}}) -- limit percentage of spike points in the data. If spike points represent a higher percentage
than the run fails the spikes check.

\item {} 
\textbf{\texttt{chunk\_size}} (\emph{\texttt{str}}) -- string representing time length of chunks used in the spikes and standard deviation check. Default is ``2Min''.
Putting None will not separate in chunks. It's recommended to use rolling functions in this case (might be slow).

\item {} 
\textbf{\texttt{RAT}} (\emph{\texttt{bool}}) -- whether or not to perform the reverse arrangement test on data.

\item {} 
\textbf{\texttt{RAT\_vars}} (\emph{\texttt{list}}) -- list containing the name of variables to go through the reverse arrangement test. If None, all variables are tested.

\item {} 
\textbf{\texttt{RAT\_points}} (\emph{\texttt{int}}) -- number of final points to apply the RAT. If 50, the run will be averaged to a 50-points run.

\item {} 
\textbf{\texttt{RAT\_significance}} -- significance level to apply the RAT.

\item {} 
\textbf{\texttt{RAT\_detrend\_kw}} -- keywords to be passed to pymicra.detrend specifically to be used on the RA test. \{``how'':''linear''\}
is strongly recommended for this case.

\item {} 
\textbf{\texttt{trueverbose}} (\emph{\texttt{bool}}) -- whether or not to show details on the successful runs.

\item {} 
\textbf{\texttt{falseverbose}} (\emph{\texttt{bool}}) -- whether or not to show details on the failed runs.

\item {} 
\textbf{\texttt{trueshow}} (\emph{\texttt{bool}}) -- whether of not to plot the successful runs on screen.

\item {} 
\textbf{\texttt{trueshow\_vars}} (\emph{\texttt{list}}) -- list of columns to plot if run is successfull.

\item {} 
\textbf{\texttt{falseshow}} (\emph{\texttt{bool}}) -- whether of not to plot the failed runs on screen.

\item {} 
\textbf{\texttt{outdir}} (\emph{\texttt{str}}) -- name of directory in which to write the successful runs. Directory must already exist.

\item {} 
\textbf{\texttt{summary\_file}} (\emph{\texttt{str}}) -- path of file to be created with the summary of the runs. Will be overwriten if already exists.

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{ext\_summary} -- dict with the extended summary, which has the path of the files that got ``stuck'' in each test along with the successful ones

\item[{Return type}] \leavevmode
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{separateFiles() (in module pymicra.util)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.util.separateFiles}\pysiglinewithargsret{\sphinxcode{pymicra.util.}\sphinxbfcode{separateFiles}}{\emph{files}, \emph{dlconfig}, \emph{outformat='out\_\%Y-\%m-\%d\_\%H:\%M.csv'}, \emph{outdir='`}, \emph{verbose=False}, \emph{firstflag='.first'}, \emph{lastflag='.last'}, \emph{save\_ram=False}, \emph{frequency=`30min'}, \emph{quoting=0}, \emph{use\_edges=False}}{}
Separates files into (default) 30-minute smaller files. Useful for output files such
as the ones by Campbell Sci, that can have days of data in one single file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{files}} (\emph{\texttt{list}}) -- list of file paths to be separated

\item {} 
\textbf{\texttt{dlconfig}} (\emph{\texttt{pymicra datalogger configuration file}}) -- to tell how the dates are displayed inside the file

\item {} 
\textbf{\texttt{outformat}} (\emph{\texttt{str}}) -- the format of the file names to output

\item {} 
\textbf{\texttt{outdir}} (\emph{\texttt{str}}) -- the path to the directory in which to output the files

\item {} 
\textbf{\texttt{verbose}} (\emph{\texttt{bool}}) -- whether to print to the screen

\item {} 
\textbf{\texttt{firstflag}} (\emph{\texttt{str}}) -- flag to put after the name of the file for the first file to be created

\item {} 
\textbf{\texttt{lastflag}} (\emph{\texttt{str}}) -- flag to put after the name of the fle for the last file to be created

\item {} 
\textbf{\texttt{save\_ram}} (\emph{\texttt{bool}}) -- if you have an amount of files that are to big for pandas to load on your ram this should be set to true

\item {} 
\textbf{\texttt{frequency}} -- the frequency in which to separate

\item {} 
\textbf{\texttt{quoting}} (\emph{\texttt{int}}) -- for pandas (see read\_csv documentation)

\item {} 
\textbf{\texttt{edges}} (\emph{\texttt{use}}) -- use this carefully. This concatenates the last few lines of a file to the first few lines
of the next file in case they don't finish on a nice round time with respect to the frequency

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{p}
\item {\texttt{pymicra.algs}}, \pageref{pymicra.algs:module-pymicra.algs}
\item {\texttt{pymicra.algs.auxiliar}}, \pageref{pymicra.algs:module-pymicra.algs.auxiliar}
\item {\texttt{pymicra.algs.general}}, \pageref{pymicra.algs:module-pymicra.algs.general}
\item {\texttt{pymicra.algs.numeric}}, \pageref{pymicra.algs:module-pymicra.algs.numeric}
\item {\texttt{pymicra.algs.units}}, \pageref{pymicra.algs:module-pymicra.algs.units}
\item {\texttt{pymicra.constants}}, \pageref{pymicra:module-pymicra.constants}
\item {\texttt{pymicra.core}}, \pageref{pymicra:module-pymicra.core}
\item {\texttt{pymicra.data}}, \pageref{pymicra:module-pymicra.data}
\item {\texttt{pymicra.decorators}}, \pageref{pymicra:module-pymicra.decorators}
\item {\texttt{pymicra.io}}, \pageref{pymicra:module-pymicra.io}
\item {\texttt{pymicra.methods}}, \pageref{pymicra:module-pymicra.methods}
\item {\texttt{pymicra.micro}}, \pageref{pymicra.micro:module-pymicra.micro}
\item {\texttt{pymicra.micro.functions}}, \pageref{pymicra.micro:module-pymicra.micro.functions}
\item {\texttt{pymicra.micro.scales}}, \pageref{pymicra.micro:module-pymicra.micro.scales}
\item {\texttt{pymicra.micro.spectral}}, \pageref{pymicra.micro:module-pymicra.micro.spectral}
\item {\texttt{pymicra.micro.util}}, \pageref{pymicra.micro:module-pymicra.micro.util}
\item {\texttt{pymicra.physics}}, \pageref{pymicra:module-pymicra.physics}
\item {\texttt{pymicra.tests}}, \pageref{pymicra:module-pymicra.tests}
\item {\texttt{pymicra.util}}, \pageref{pymicra:module-pymicra.util}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
